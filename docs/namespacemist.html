<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ネームスペース mist</title>
<link href="mist.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- 作成： Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li class="current"><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li><a href="annotated.html"><span>データ構造</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>ネームスペース一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>ネームスペースメンバ</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">ネームスペース</a> &#124;
<a href="#nested-classes">データ構造</a> &#124;
<a href="#func-members">関数</a>  </div>
  <div class="headertitle">
<div class="title">ネームスペース mist</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
ネームスペース</h2></td></tr>
<tr class="memitem:namespacemist_1_1Armijo"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1Armijo.html">Armijo</a></td></tr>
<tr class="memdesc:namespacemist_1_1Armijo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Armijoの基準を用いた極小値の一次元探索 <br/></td></tr>
<tr class="memitem:namespacemist_1_1average"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1average.html">average</a></td></tr>
<tr class="memdesc:namespacemist_1_1average"><td class="mdescLeft">&#160;</td><td class="mdescRight">一様重み平滑化フィルタの実装（コールバック関数を指定することが可能） <br/></td></tr>
<tr class="memitem:namespacemist_1_1brent"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1brent.html">brent</a></td></tr>
<tr class="memdesc:namespacemist_1_1brent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brent の放物線補間を用いた極小値の1次元探索（2次収束） <br/></td></tr>
<tr class="memitem:namespacemist_1_1BSpline"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1BSpline.html">BSpline</a></td></tr>
<tr class="memdesc:namespacemist_1_1BSpline"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次のBスプライン関数を用いた補間 <br/></td></tr>
<tr class="memitem:namespacemist_1_1calvin"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1calvin.html">calvin</a></td></tr>
<tr class="memdesc:namespacemist_1_1calvin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calvinによるユークリッド2乗距離変換 <br/></td></tr>
<tr class="memitem:namespacemist_1_1chessboard"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1chessboard.html">chessboard</a></td></tr>
<tr class="memdesc:namespacemist_1_1chessboard"><td class="mdescLeft">&#160;</td><td class="mdescRight">チェスボード距離変換 <br/></td></tr>
<tr class="memitem:namespacemist_1_1cityblock"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1cityblock.html">cityblock</a></td></tr>
<tr class="memdesc:namespacemist_1_1cityblock"><td class="mdescLeft">&#160;</td><td class="mdescRight">マンハッタン距離（シティーブロック距離）変換 <br/></td></tr>
<tr class="memitem:namespacemist_1_1condor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1condor.html">condor</a></td></tr>
<tr class="memdesc:namespacemist_1_1condor"><td class="mdescLeft">&#160;</td><td class="mdescRight">CONDOR法（多変数関数の極小値の探索） <br/></td></tr>
<tr class="memitem:namespacemist_1_1conjugate__gradient"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1conjugate__gradient.html">conjugate_gradient</a></td></tr>
<tr class="memdesc:namespacemist_1_1conjugate__gradient"><td class="mdescLeft">&#160;</td><td class="mdescRight">共役勾配法（勾配を用いた多変数関数の極小値の探索） <br/></td></tr>
<tr class="memitem:namespacemist_1_1cubic"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1cubic.html">cubic</a></td></tr>
<tr class="memdesc:namespacemist_1_1cubic"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次のsinc関数を用いた補間 <br/></td></tr>
<tr class="memitem:namespacemist_1_1dicom"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1dicom.html">dicom</a></td></tr>
<tr class="memdesc:namespacemist_1_1dicom"><td class="mdescLeft">&#160;</td><td class="mdescRight">DICOMファイルを操作する関数・クラスを含む名前空間 <br/></td></tr>
<tr class="memitem:namespacemist_1_1discriminant__analysis"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1discriminant__analysis.html">discriminant_analysis</a></td></tr>
<tr class="memdesc:namespacemist_1_1discriminant__analysis"><td class="mdescLeft">&#160;</td><td class="mdescRight">判別分析法に基づくしきい値決定 <br/></td></tr>
<tr class="memitem:namespacemist_1_1euclidean"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1euclidean.html">euclidean</a></td></tr>
<tr class="memdesc:namespacemist_1_1euclidean"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユークリッド距離変換 <br/></td></tr>
<tr class="memitem:namespacemist_1_1gauss"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1gauss.html">gauss</a></td></tr>
<tr class="memdesc:namespacemist_1_1gauss"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規乱数のジェネレータ <br/></td></tr>
<tr class="memitem:namespacemist_1_1gaussian"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1gaussian.html">gaussian</a></td></tr>
<tr class="memdesc:namespacemist_1_1gaussian"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガウシアンフィルタの実装（コールバック関数を指定することが可能） <br/></td></tr>
<tr class="memitem:namespacemist_1_1gold"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1gold.html">gold</a></td></tr>
<tr class="memdesc:namespacemist_1_1gold"><td class="mdescLeft">&#160;</td><td class="mdescRight">黄金分割を用いた極小値の1次元探索（1次収束） <br/></td></tr>
<tr class="memitem:namespacemist_1_1gradient"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1gradient.html">gradient</a></td></tr>
<tr class="memdesc:namespacemist_1_1gradient"><td class="mdescLeft">&#160;</td><td class="mdescRight">最急降下法（勾配を用いた多変数関数の極小値の探索） <br/></td></tr>
<tr class="memitem:namespacemist_1_1gradient__with__vector"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1gradient__with__vector.html">gradient_with_vector</a></td></tr>
<tr class="memdesc:namespacemist_1_1gradient__with__vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">勾配関数をユーザーが定義する最急降下法（勾配を用いた多変数関数の極小値の探索） <br/></td></tr>
<tr class="memitem:namespacemist_1_1hilditch"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1hilditch.html">hilditch</a></td></tr>
<tr class="memdesc:namespacemist_1_1hilditch"><td class="mdescLeft">&#160;</td><td class="mdescRight">C. J. Hilditch の細線化アルゴリズム <br/></td></tr>
<tr class="memitem:namespacemist_1_1histogram"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1histogram.html">histogram</a></td></tr>
<tr class="memdesc:namespacemist_1_1histogram"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒストグラムから正規分布の混合分布を推定する関数群 <br/></td></tr>
<tr class="memitem:namespacemist_1_1laplacian"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1laplacian.html">laplacian</a></td></tr>
<tr class="memdesc:namespacemist_1_1laplacian"><td class="mdescLeft">&#160;</td><td class="mdescRight">ラプラシアンフィルタの実装（コールバック関数を指定することが可能） <br/></td></tr>
<tr class="memitem:namespacemist_1_1linear"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1linear.html">linear</a></td></tr>
<tr class="memdesc:namespacemist_1_1linear"><td class="mdescLeft">&#160;</td><td class="mdescRight">一般カーネルの線形フィルタの実装（コールバック関数を指定することが可能） <br/></td></tr>
<tr class="memitem:namespacemist_1_1lucidi"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1lucidi.html">lucidi</a></td></tr>
<tr class="memdesc:namespacemist_1_1lucidi"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lucidi法（方向集合を用いた多変数関数の極小値の探索） <br/></td></tr>
<tr class="memitem:namespacemist_1_1machine__learning"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1machine__learning.html">machine_learning</a></td></tr>
<tr class="memdesc:namespacemist_1_1machine__learning"><td class="mdescLeft">&#160;</td><td class="mdescRight">機械学習 <br/></td></tr>
<tr class="memitem:namespacemist_1_1manhattan"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1manhattan.html">manhattan</a></td></tr>
<tr class="memdesc:namespacemist_1_1manhattan"><td class="mdescLeft">&#160;</td><td class="mdescRight">マンハッタン距離（シティーブロック距離）変換 <br/></td></tr>
<tr class="memitem:namespacemist_1_1mean"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1mean.html">mean</a></td></tr>
<tr class="memdesc:namespacemist_1_1mean"><td class="mdescLeft">&#160;</td><td class="mdescRight">平均値型補間 <br/></td></tr>
<tr class="memitem:namespacemist_1_1meijster"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1meijster.html">meijster</a></td></tr>
<tr class="memdesc:namespacemist_1_1meijster"><td class="mdescLeft">&#160;</td><td class="mdescRight">A. Meijster による距離変換（CDT, MDT） <br/></td></tr>
<tr class="memitem:namespacemist_1_1mixture"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1mixture.html">mixture</a></td></tr>
<tr class="memdesc:namespacemist_1_1mixture"><td class="mdescLeft">&#160;</td><td class="mdescRight">混合分布推定に用いるパラメータ <br/></td></tr>
<tr class="memitem:namespacemist_1_1mode__filter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1mode__filter.html">mode_filter</a></td></tr>
<tr class="memdesc:namespacemist_1_1mode__filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">最頻値フィルタに利用する構造要素関連 <br/></td></tr>
<tr class="memitem:namespacemist_1_1morphology"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1morphology.html">morphology</a></td></tr>
<tr class="memdesc:namespacemist_1_1morphology"><td class="mdescLeft">&#160;</td><td class="mdescRight">モルフォロジ演算に利用する構造要素関連 <br/></td></tr>
<tr class="memitem:namespacemist_1_1multivariate__gauss"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1multivariate__gauss.html">multivariate_gauss</a></td></tr>
<tr class="memdesc:namespacemist_1_1multivariate__gauss"><td class="mdescLeft">&#160;</td><td class="mdescRight">多変量正規乱数のジェネレータ <br/></td></tr>
<tr class="memitem:namespacemist_1_1nearest"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1nearest.html">nearest</a></td></tr>
<tr class="memdesc:namespacemist_1_1nearest"><td class="mdescLeft">&#160;</td><td class="mdescRight">最近傍型補間 <br/></td></tr>
<tr class="memitem:namespacemist_1_1non__rigid"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1non__rigid.html">non_rigid</a></td></tr>
<tr class="memdesc:namespacemist_1_1non__rigid"><td class="mdescLeft">&#160;</td><td class="mdescRight">FFDを用いた非剛体レジストレーション <br/></td></tr>
<tr class="memitem:namespacemist_1_1poisson"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1poisson.html">poisson</a></td></tr>
<tr class="memdesc:namespacemist_1_1poisson"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポアソン分布に従う乱数のジェネレータ <br/></td></tr>
<tr class="memitem:namespacemist_1_1powell"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1powell.html">powell</a></td></tr>
<tr class="memdesc:namespacemist_1_1powell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Powell法（方向集合を用いた多変数関数の極小値の探索） <br/></td></tr>
<tr class="memitem:namespacemist_1_1ptile"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1ptile.html">ptile</a></td></tr>
<tr class="memdesc:namespacemist_1_1ptile"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pタイル法に基づくしきい値決定 <br/></td></tr>
<tr class="memitem:namespacemist_1_1region__growing__utility"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1region__growing__utility.html">region_growing_utility</a></td></tr>
<tr class="memdesc:namespacemist_1_1region__growing__utility"><td class="mdescLeft">&#160;</td><td class="mdescRight">領域拡張法に利用する構造要素関連 <br/></td></tr>
<tr class="memitem:namespacemist_1_1saito"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1saito.html">saito</a></td></tr>
<tr class="memdesc:namespacemist_1_1saito"><td class="mdescLeft">&#160;</td><td class="mdescRight">斉藤先生によるユークリッド2乗距離変換 <br/></td></tr>
<tr class="memitem:namespacemist_1_1sinc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1sinc.html">sinc</a></td></tr>
<tr class="memdesc:namespacemist_1_1sinc"><td class="mdescLeft">&#160;</td><td class="mdescRight">sinc関数を用いた補間 <br/></td></tr>
<tr class="memitem:namespacemist_1_1statistics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1statistics.html">statistics</a></td></tr>
<tr class="memdesc:namespacemist_1_1statistics"><td class="mdescLeft">&#160;</td><td class="mdescRight">統計処理 <br/></td></tr>
<tr class="memitem:namespacemist_1_1Tsai"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1Tsai.html">Tsai</a></td></tr>
<tr class="memdesc:namespacemist_1_1Tsai"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacemist_1_1Tsai.html" title="Tsai のカメラキャリブレーション手法">Tsai</a> のカメラキャリブレーション手法 <br/></td></tr>
<tr class="memitem:namespacemist_1_1uniform"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1uniform.html">uniform</a></td></tr>
<tr class="memdesc:namespacemist_1_1uniform"><td class="mdescLeft">&#160;</td><td class="mdescRight">MT(Mersenne Twister)法による一様乱数 <br/></td></tr>
<tr class="memitem:namespacemist_1_1video"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist_1_1video.html">video</a></td></tr>
<tr class="memdesc:namespacemist_1_1video"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビデオファイルを扱うライブラリ <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
データ構造</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1bitmap.html">bitmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">要素数が可変のビットマップ画像を扱うクラス  <a href="classmist_1_1bitmap.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1bspline__base.html">bspline_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bスプラインの基底関数を計算する関数を実装した構造体  <a href="structmist_1_1bspline__base.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1bspline__base_3_011_01_4.html">bspline_base&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bスプラインの基底関数を計算する関数を実装した構造体の特殊化  <a href="structmist_1_1bspline__base_3_011_01_4.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1bspline.html">bspline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bスプライン曲線を扱うためのクラス  <a href="classmist_1_1bspline.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1binary.html">binary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">バイナリ演算を行うためのもの  <a href="classmist_1_1binary.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1rgb.html">rgb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カラー画像用の画素  <a href="structmist_1_1rgb.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1bgr.html">bgr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カラー画素の和  <a href="structmist_1_1bgr.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1rgba.html">rgba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カラー画素の和  <a href="structmist_1_1rgba.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1bgra.html">bgra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カラー画素の和  <a href="structmist_1_1bgra.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1nRGB.html">nRGB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カラー画素の和  <a href="structmist_1_1nRGB.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1color.html">color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カラー画素の和  <a href="structmist_1_1color.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__color.html">is_color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力された型がカラー画像かどうか調べる  <a href="structmist_1_1is__color.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1float__type_3_01rgb_3_01T_01_4_01_4.html">float_type&lt; rgb&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">char 判定  <a href="structmist_1_1float__type_3_01rgb_3_01T_01_4_01_4.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1colors.html">colors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">定義済み色  <a href="structmist_1_1colors.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionmist_1_1byte__array.html">byte_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">バイト配列と値のペアを表現するクラス  <a href="unionmist_1_1byte__array.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">mistコンテナで利用する1次元操作用ランダムアクセスイテレータ  <a href="classmist_1_1mist__iterator1.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">mistコンテナで利用する2次元操作用ランダムアクセスイテレータ  <a href="classmist_1_1mist__iterator2.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">イテレータから逆方向ランダムアクセスイテレータを生成する  <a href="classmist_1_1mist__reverse__iterator.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1mist__memory__operator.html">mist_memory_operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザー定義型用のメモリ操作関数群  <a href="structmist_1_1mist__memory__operator.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1mist__memory__operator_3true_01_4.html">mist_memory_operator&lt;true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">組み込み型用のメモリ操作関数群  <a href="structmist_1_1mist__memory__operator_3true_01_4.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1mist__allocator.html">mist_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIST内部でSTLのアロケータを効果的に利用するための仕組み  <a href="classmist_1_1mist__allocator.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1____mist__dmy__callback____.html">__mist_dmy_callback__</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTのアルゴリズム全般で利用するダミーコールバックファンクタ  <a href="structmist_1_1____mist__dmy__callback____.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1____mist__convert__callback____.html">__mist_convert_callback__</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したコールバックの戻り値 [0,100] を指定した区間に変換する  <a href="structmist_1_1____mist__convert__callback____.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1____mist__console__callback____.html">__mist_console_callback__</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTのアルゴリズム全般で利用可能な，標準出力型コールバックファンクタ  <a href="structmist_1_1____mist__console__callback____.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1____mist__progress__callback____.html">__mist_progress_callback__</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTのアルゴリズム全般で利用可能な，進行状況表示型ダミーコールバックファンクタ  <a href="structmist_1_1____mist__progress__callback____.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1scoped__ptr.html">scoped_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">オブジェクトのスコープが切れると自動的にメモリ開放を行うポインタ  <a href="classmist_1_1scoped__ptr.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1scoped__array.html">scoped_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">オブジェクトのスコープが切れると配列用に確保したメモリの自動開放を行うポインタ  <a href="classmist_1_1scoped__array.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1shared__ptr.html">shared_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">オブジェクトへのポインタの参照カウントを管理し，どこからも参照されなくなったときにメモリを自動開放するポインタ  <a href="classmist_1_1shared__ptr.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1shared__array.html">shared_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">配列へのポインタの参照カウントを管理し，どこからも参照されなくなったときにメモリを自動開放するポインタ  <a href="classmist_1_1shared__array.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1weak__ptr.html">weak_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照カウント型のメモリに対する，弱参照を扱うポインタ  <a href="classmist_1_1weak__ptr.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1set__base.html">set_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合を扱うための基本クラス  <a href="classmist_1_1set__base.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1set.html">set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合演算を行うことができる，STLの set の拡張版  <a href="classmist_1_1set.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1multiset.html">multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合演算を行うことができる，STLの set の拡張版  <a href="classmist_1_1multiset.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1stereo.html">stereo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ステレオ音声用のデータ型  <a href="structmist_1_1stereo.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__stereo.html">is_stereo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力された型が音声データかどうか調べる  <a href="structmist_1_1is__stereo.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__char.html">is_char</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">char 判定  <a href="structmist_1_1is__char.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__float.html">is_float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">浮動小数点 判定  <a href="structmist_1_1is__float.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__integer.html">is_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer 判定  <a href="structmist_1_1is__integer.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__signed.html">is_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">符号付き型かどうか判定  <a href="structmist_1_1is__signed.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">arithmetic 判定  <a href="structmist_1_1is__arithmetic.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1is__builtin.html">is_builtin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">組み込み型の判定  <a href="structmist_1_1is__builtin.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1float__type.html">float_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">対応する float 型を返す  <a href="structmist_1_1float__type.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1promote__trait.html">promote_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型の昇格型を返す  <a href="structmist_1_1promote__trait.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1type__trait.html">type_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">データ型の確定を避けるために利用する  <a href="structmist_1_1type__trait.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1half__adjust.html">half_adjust</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">値の四捨五入をする  <a href="structmist_1_1half__adjust.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1type__and.html">type_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型のAND演算を行う  <a href="structmist_1_1type__and.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1type__or.html">type_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型のOR演算を行う型  <a href="structmist_1_1type__or.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1type__not.html">type_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型のNOT演算を行う型  <a href="structmist_1_1type__not.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1type__equal.html">type_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型のEQUAL演算を行う型  <a href="structmist_1_1type__equal.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1crc.html">crc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC を生成・検証を行うクラス  <a href="structmist_1_1crc.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1facet.html">facet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴン（三角形）を扱うクラス  <a href="classmist_1_1facet.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1facet__list.html">facet_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴン（三角形）の集合を扱うクラス  <a href="classmist_1_1facet__list.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1hash__algorithm.html">hash_algorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ハッシュ関数を計算する基底クラス  <a href="classmist_1_1hash__algorithm.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1integral__image.html">integral_image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元の積分画像を保持し，任意の矩形領域の画素値の総和を高速に計算するためのクラス  <a href="classmist_1_1integral__image.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1integral__image_3_01array_3_01T_00_01Allocator_01_4_01_4.html">integral_image&lt; array&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元の積分画像を保持し，任意の矩形領域の画素値の総和を高速に計算するためのクラス  <a href="classmist_1_1integral__image_3_01array_3_01T_00_01Allocator_01_4_01_4.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1integral__image_3_01array2_3_01T_00_01Allocator_01_4_01_4.html">integral_image&lt; array2&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元の積分画像を保持し，任意の矩形領域の画素値の総和を高速に計算するためのクラス  <a href="classmist_1_1integral__image_3_01array2_3_01T_00_01Allocator_01_4_01_4.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1integral__image_3_01array3_3_01T_00_01Allocator_01_4_01_4.html">integral_image&lt; array3&lt; T, Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元の積分画像を保持し，任意の矩形領域の画素値の総和を高速に計算するためのクラス  <a href="classmist_1_1integral__image_3_01array3_3_01T_00_01Allocator_01_4_01_4.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1type__limits.html">type_limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力された型の情報を取得する  <a href="structmist_1_1type__limits.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1marching__cubes.html">marching_cubes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームデータから等値面を生成するためのクラス  <a href="classmist_1_1marching__cubes.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">行と列の要素数が可変の行列  <a href="classmist_1_1matrix.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1md2.html">md2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MD2 を生成するクラス  <a href="classmist_1_1md2.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1md4.html">md4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MD4 を生成するクラス  <a href="classmist_1_1md4.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1md5.html">md5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MD5 を生成するクラス  <a href="classmist_1_1md5.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">要素数が可変の1次元配列  <a href="classmist_1_1array.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1array1.html">array1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">要素数が可変の解像度付1次元配列  <a href="classmist_1_1array1.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1array2.html">array2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">要素数が可変の解像度付き2次元配列  <a href="classmist_1_1array2.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1array3.html">array3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">要素数が可変の解像度付き3次元配列  <a href="classmist_1_1array3.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1marray.html">marray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像のふちにマージンを持った配列  <a href="classmist_1_1marray.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1buffered__array.html">buffered_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">１辺が2の指数乗のバッファを持った画像を作成する  <a href="classmist_1_1buffered__array.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1matrix__style.html">matrix_style</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列計算をする際の入力となる行列の形式  <a href="structmist_1_1matrix__style.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__add.html">implement_operator_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">足し算  <a href="structmist_1_1implement__operator__add.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__sub.html">implement_operator_sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">引き算  <a href="structmist_1_1implement__operator__sub.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__mul.html">implement_operator_mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">掛け算  <a href="structmist_1_1implement__operator__mul.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__div.html">implement_operator_div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">割り算  <a href="structmist_1_1implement__operator__div.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__ne.html">implement_operator_ne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">等しくない  <a href="structmist_1_1implement__operator__ne.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__gt.html">implement_operator_gt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">より大きい  <a href="structmist_1_1implement__operator__gt.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__le.html">implement_operator_le</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">以下  <a href="structmist_1_1implement__operator__le.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__ge.html">implement_operator_ge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">以上  <a href="structmist_1_1implement__operator__ge.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__mod.html">implement_operator_mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">剰余演算子  <a href="structmist_1_1implement__operator__mod.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__or.html">implement_operator_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビットOR演算子  <a href="structmist_1_1implement__operator__or.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__and.html">implement_operator_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビットAND演算子  <a href="structmist_1_1implement__operator__and.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operator__xor.html">implement_operator_xor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR演算子  <a href="structmist_1_1implement__operator__xor.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__arithmetic__operators.html">implement_arithmetic_operators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">四則演算オペレータを実装する  <a href="structmist_1_1implement__arithmetic__operators.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__comparison__operators.html">implement_comparison_operators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">比較オペレータを実装する  <a href="structmist_1_1implement__comparison__operators.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__bit__operators.html">implement_bit_operators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビット演算オペレータを実装する  <a href="structmist_1_1implement__bit__operators.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1implement__operators.html">implement_operators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">全てのオペレータを実装する  <a href="structmist_1_1implement__operators.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1quaternion.html">quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">クォータニオン（四元数）を扱うクラス  <a href="classmist_1_1quaternion.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1sha1.html">sha1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-1 を生成するクラス  <a href="classmist_1_1sha1.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1sha256.html">sha256</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-256 を生成するクラス  <a href="classmist_1_1sha256.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1sha384.html">sha384</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-384 を生成するクラス  <a href="classmist_1_1sha384.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1sha512.html">sha512</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-512 を生成するクラス  <a href="classmist_1_1sha512.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1singleton.html">singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton を扱うクラス  <a href="classmist_1_1singleton.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1spline.html">spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次スプライン曲線を扱うためのクラス  <a href="classmist_1_1spline.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1tensor.html">tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor class.  <a href="classmist_1_1tensor.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1simple__lock__object.html">simple_lock_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドの排他制御をサポートする最も単純なクラス  <a href="structmist_1_1simple__lock__object.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmist_1_1lock__object.html">lock_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドの排他制御をサポートするクラス  <a href="structmist_1_1lock__object.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1lock.html">lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドの排他制御を簡便に記述するためのヘルパクラス  <a href="classmist_1_1lock.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1thread.html">thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template 型のデータを扱うことができるスレッドクラス  <a href="classmist_1_1thread.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドプールを利用してスレッドの再利用を可能にするクラス  <a href="classmist_1_1thread__pool.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1worker__thread.html">worker_thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">バックグラウンドで実行するワーカースレッドを実現するクラス  <a href="classmist_1_1worker__thread.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1thread__handle.html">thread_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">生成したスレッドを管理するクラス  <a href="classmist_1_1thread__handle.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1timer.html">timer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1stopwatch.html">stopwatch</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1options.html">options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">コマンドライン引数を解析するクラス  <a href="classmist_1_1options.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1vector3.html">vector3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元ベクトルを扱うクラス  <a href="classmist_1_1vector3.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1vector2.html">vector2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元ベクトルを扱うクラス  <a href="classmist_1_1vector2.html#details">[詳細]</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmist_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N次元ベクトルを扱うクラス  <a href="classmist_1_1vector.html#details">[詳細]</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:aa9b4500a2d074b160500029dea1cff68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9b4500a2d074b160500029dea1cff68"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#aa9b4500a2d074b160500029dea1cff68">cross_correlation</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T &gt; &amp;signal1, const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T &gt; &amp;signal2, int tau, bool biased=true)</td></tr>
<tr class="memdesc:aa9b4500a2d074b160500029dea1cff68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross correlation.  <a href="#aa9b4500a2d074b160500029dea1cff68"></a><br/></td></tr>
<tr class="memitem:a386c548a90409bdbbbb5573b48d9eae7"><td class="memTemplParams" colspan="2">template&lt;typename T , class Allocator &gt; </td></tr>
<tr class="memitem:a386c548a90409bdbbbb5573b48d9eae7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a386c548a90409bdbbbb5573b48d9eae7">autocorrelation</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt; &amp;signal, int tau, bool biased=true)</td></tr>
<tr class="memdesc:a386c548a90409bdbbbb5573b48d9eae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Autocorrelation.  <a href="#a386c548a90409bdbbbb5573b48d9eae7"></a><br/></td></tr>
<tr class="memitem:a8e529d6681f45a72fb06d36ead8d0ee3"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class T3 , class Allocator3 &gt; </td></tr>
<tr class="memitem:a8e529d6681f45a72fb06d36ead8d0ee3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a8e529d6681f45a72fb06d36ead8d0ee3">parcor</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;cor, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;alf, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T3, Allocator3 &gt; &amp;ref, int p)</td></tr>
<tr class="memdesc:a8e529d6681f45a72fb06d36ead8d0ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate PARCOR and linear predict cofficients from autocorrelation values.  <a href="#a8e529d6681f45a72fb06d36ead8d0ee3"></a><br/></td></tr>
<tr class="memitem:a59e0301c0d45c4af3a57b0cc117c644a"><td class="memTemplParams" colspan="2">template&lt;size_t BITS, class Allocator &gt; </td></tr>
<tr class="memitem:a59e0301c0d45c4af3a57b0cc117c644a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a59e0301c0d45c4af3a57b0cc117c644a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS, Allocator &gt; &amp;a)</td></tr>
<tr class="memdesc:a59e0301c0d45c4af3a57b0cc117c644a"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="#a59e0301c0d45c4af3a57b0cc117c644a"></a><br/></td></tr>
<tr class="memitem:ad6a11e6996a5e91f5ec79ab5ccc1fc48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6a11e6996a5e91f5ec79ab5ccc1fc48"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#ad6a11e6996a5e91f5ec79ab5ccc1fc48">operator+</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:ad6a11e6996a5e91f5ec79ab5ccc1fc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a76b26690b1a81e5997da88f84273b1b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76b26690b1a81e5997da88f84273b1b4"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a76b26690b1a81e5997da88f84273b1b4">operator-</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:a76b26690b1a81e5997da88f84273b1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a56980d374de8ac5cf3634f27f59f0f79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56980d374de8ac5cf3634f27f59f0f79"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a56980d374de8ac5cf3634f27f59f0f79">operator*</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:a56980d374de8ac5cf3634f27f59f0f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a9759485f1f06bc63c3b6b1610e1ab670"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9759485f1f06bc63c3b6b1610e1ab670"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a9759485f1f06bc63c3b6b1610e1ab670">operator/</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:a9759485f1f06bc63c3b6b1610e1ab670"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:af83ec4ef29d5134585d527d117c317ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af83ec4ef29d5134585d527d117c317ff"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#af83ec4ef29d5134585d527d117c317ff">operator%</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:af83ec4ef29d5134585d527d117c317ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:aba7d4a91a94945d74582dcb03a838946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba7d4a91a94945d74582dcb03a838946"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#aba7d4a91a94945d74582dcb03a838946">operator|</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:aba7d4a91a94945d74582dcb03a838946"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a32b285bf9a87d14b443f27b4db936842"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32b285bf9a87d14b443f27b4db936842"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a32b285bf9a87d14b443f27b4db936842">operator&amp;</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:a32b285bf9a87d14b443f27b4db936842"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a8302a5a0d7ae4e2b9145ab5bc3ec3f29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8302a5a0d7ae4e2b9145ab5bc3ec3f29"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a8302a5a0d7ae4e2b9145ab5bc3ec3f29">operator^</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:a8302a5a0d7ae4e2b9145ab5bc3ec3f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a28de0d938cb9dc7a326df34a9319ccf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28de0d938cb9dc7a326df34a9319ccf8"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a28de0d938cb9dc7a326df34a9319ccf8">operator*</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html#a021df6f86303a7d1998615c2fc7071ab">binary::value_type</a> &amp;b2)</td></tr>
<tr class="memdesc:a28de0d938cb9dc7a326df34a9319ccf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a0df5650b89c8108675dd934e3bdf0ccd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0df5650b89c8108675dd934e3bdf0ccd"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a0df5650b89c8108675dd934e3bdf0ccd">operator*</a> (const <a class="el" href="classmist_1_1binary.html#a021df6f86303a7d1998615c2fc7071ab">binary::value_type</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:a0df5650b89c8108675dd934e3bdf0ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:ab5d995054f6c25e75ccbd0fb54cd42ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5d995054f6c25e75ccbd0fb54cd42ba"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#ab5d995054f6c25e75ccbd0fb54cd42ba">operator/</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html#a021df6f86303a7d1998615c2fc7071ab">binary::value_type</a> &amp;b2)</td></tr>
<tr class="memdesc:ab5d995054f6c25e75ccbd0fb54cd42ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:afa7b713268c5b30a51e7e8f1b046cafb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7b713268c5b30a51e7e8f1b046cafb"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#afa7b713268c5b30a51e7e8f1b046cafb">operator+</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html#a021df6f86303a7d1998615c2fc7071ab">binary::value_type</a> &amp;b2)</td></tr>
<tr class="memdesc:afa7b713268c5b30a51e7e8f1b046cafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a951161dc0295192cd578bc933f435523"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a951161dc0295192cd578bc933f435523"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a951161dc0295192cd578bc933f435523">operator+</a> (const <a class="el" href="classmist_1_1binary.html#a021df6f86303a7d1998615c2fc7071ab">binary::value_type</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:a951161dc0295192cd578bc933f435523"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a11aa40c48081529db74dfe92b7e523f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11aa40c48081529db74dfe92b7e523f9"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a11aa40c48081529db74dfe92b7e523f9">operator-</a> (const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html#a021df6f86303a7d1998615c2fc7071ab">binary::value_type</a> &amp;b2)</td></tr>
<tr class="memdesc:a11aa40c48081529db74dfe92b7e523f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:aabfa98fb2ecb7d62d7c5b5ba9c289191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabfa98fb2ecb7d62d7c5b5ba9c289191"></a>
const <a class="el" href="classmist_1_1binary.html">binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#aabfa98fb2ecb7d62d7c5b5ba9c289191">operator-</a> (const <a class="el" href="classmist_1_1binary.html#a021df6f86303a7d1998615c2fc7071ab">binary::value_type</a> &amp;b1, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b2)</td></tr>
<tr class="memdesc:aabfa98fb2ecb7d62d7c5b5ba9c289191"><td class="mdescLeft">&#160;</td><td class="mdescRight">論理演算 <br/></td></tr>
<tr class="memitem:a6716e367d9065508b7b197f151ab713b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a6716e367d9065508b7b197f151ab713b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1binary.html">binary</a> &amp;b)</td></tr>
<tr class="memdesc:a6716e367d9065508b7b197f151ab713b"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="#a6716e367d9065508b7b197f151ab713b"></a><br/></td></tr>
<tr class="memitem:gafb3b0a37bc167ec836a25bbf6ff6e1c9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gafb3b0a37bc167ec836a25bbf6ff6e1c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color__group.html#gafb3b0a37bc167ec836a25bbf6ff6e1c9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structmist_1_1rgb.html">rgb</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="memdesc:gafb3b0a37bc167ec836a25bbf6ff6e1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">カラー画素の和  <a href="group__color__group.html#gafb3b0a37bc167ec836a25bbf6ff6e1c9"></a><br/></td></tr>
<tr class="memitem:ga84a0c324648514df6c4a2e81ee506326"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga84a0c324648514df6c4a2e81ee506326"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga84a0c324648514df6c4a2e81ee506326">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structmist_1_1rgba.html">rgba</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="memdesc:ga84a0c324648514df6c4a2e81ee506326"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__color__group.html#ga84a0c324648514df6c4a2e81ee506326"></a><br/></td></tr>
<tr class="memitem:gac19730e61808d5ed56e36701e5bd222c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac19730e61808d5ed56e36701e5bd222c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color__group.html#gac19730e61808d5ed56e36701e5bd222c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structmist_1_1nRGB.html">nRGB</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="memdesc:gac19730e61808d5ed56e36701e5bd222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__color__group.html#gac19730e61808d5ed56e36701e5bd222c"></a><br/></td></tr>
<tr class="memitem:ga4cf480138643c71dec5cd909500231b3"><td class="memTemplParams" colspan="2">template&lt;class T , size_t NDIM&gt; </td></tr>
<tr class="memitem:ga4cf480138643c71dec5cd909500231b3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga4cf480138643c71dec5cd909500231b3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structmist_1_1color.html">color</a>&lt; T, NDIM &gt; &amp;c)</td></tr>
<tr class="memdesc:ga4cf480138643c71dec5cd909500231b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__color__group.html#ga4cf480138643c71dec5cd909500231b3"></a><br/></td></tr>
<tr class="memitem:gae42505ff88c40dfd1dfbcb1b8cfec0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#gae42505ff88c40dfd1dfbcb1b8cfec0a2">rgb2hsv</a> (double r, double g, double b, double &amp;h, double &amp;s, double &amp;v)</td></tr>
<tr class="memdesc:gae42505ff88c40dfd1dfbcb1b8cfec0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB色空間をHSV色空間に変換する  <a href="group__color__group.html#gae42505ff88c40dfd1dfbcb1b8cfec0a2"></a><br/></td></tr>
<tr class="memitem:ga34c5bc869545a0a4ba09ae8b27a85b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga34c5bc869545a0a4ba09ae8b27a85b9c">hsv2rgb</a> (double h, double s, double v, double &amp;r, double &amp;g, double &amp;b)</td></tr>
<tr class="memdesc:ga34c5bc869545a0a4ba09ae8b27a85b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">HSV色空間をRGB色空間に変換する  <a href="group__color__group.html#ga34c5bc869545a0a4ba09ae8b27a85b9c"></a><br/></td></tr>
<tr class="memitem:ga875d639f54578382aa75a3dad2b8540b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga875d639f54578382aa75a3dad2b8540b">rgb2yiq</a> (double r, double g, double b, double &amp;y, double &amp;i, double &amp;q)</td></tr>
<tr class="memdesc:ga875d639f54578382aa75a3dad2b8540b"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB色空間をYIQ色空間に変換する  <a href="group__color__group.html#ga875d639f54578382aa75a3dad2b8540b"></a><br/></td></tr>
<tr class="memitem:ga9620938a382f5fa7876ac182f0568f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga9620938a382f5fa7876ac182f0568f81">yiq2rgb</a> (double y, double i, double q, double &amp;r, double &amp;g, double &amp;b)</td></tr>
<tr class="memdesc:ga9620938a382f5fa7876ac182f0568f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">YIQ色空間をRGB色空間に変換する  <a href="group__color__group.html#ga9620938a382f5fa7876ac182f0568f81"></a><br/></td></tr>
<tr class="memitem:ga7bbda68f0fecb0fb68920346ad6be705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga7bbda68f0fecb0fb68920346ad6be705">rgb2ycbcr</a> (double r, double g, double b, double &amp;y, double &amp;cb, double &amp;cr)</td></tr>
<tr class="memdesc:ga7bbda68f0fecb0fb68920346ad6be705"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB色空間をYCbCr色空間に変換する  <a href="group__color__group.html#ga7bbda68f0fecb0fb68920346ad6be705"></a><br/></td></tr>
<tr class="memitem:gacd12541e13faffbe74fd9a995e011af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#gacd12541e13faffbe74fd9a995e011af7">ycbcr2rgb</a> (double y, double cb, double cr, double &amp;r, double &amp;g, double &amp;b)</td></tr>
<tr class="memdesc:gacd12541e13faffbe74fd9a995e011af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">YCbCr色空間をRGB色空間に変換する  <a href="group__color__group.html#gacd12541e13faffbe74fd9a995e011af7"></a><br/></td></tr>
<tr class="memitem:ga9bf627ce7c7276b8e54c8f6a3410d664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga9bf627ce7c7276b8e54c8f6a3410d664">rgb2xyz</a> (double r, double g, double b, double &amp;x, double &amp;y, double &amp;z)</td></tr>
<tr class="memdesc:ga9bf627ce7c7276b8e54c8f6a3410d664"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB色空間をXYZ色空間に変換する  <a href="group__color__group.html#ga9bf627ce7c7276b8e54c8f6a3410d664"></a><br/></td></tr>
<tr class="memitem:ga6f1849ea887dadf53a8ef89a56049787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga6f1849ea887dadf53a8ef89a56049787">xyz2rgb</a> (double x, double y, double z, double &amp;r, double &amp;g, double &amp;b)</td></tr>
<tr class="memdesc:ga6f1849ea887dadf53a8ef89a56049787"><td class="mdescLeft">&#160;</td><td class="mdescRight">XYZ色空間をRGB色空間に変換する  <a href="group__color__group.html#ga6f1849ea887dadf53a8ef89a56049787"></a><br/></td></tr>
<tr class="memitem:gabd5531211fe6481ae17826b7039ad4c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#gabd5531211fe6481ae17826b7039ad4c2">rgb2lab</a> (double r, double g, double b, double &amp;l_, double &amp;a_, double &amp;b_)</td></tr>
<tr class="memdesc:gabd5531211fe6481ae17826b7039ad4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB色空間をL*a*b*色空間に変換する  <a href="group__color__group.html#gabd5531211fe6481ae17826b7039ad4c2"></a><br/></td></tr>
<tr class="memitem:ga5f19cd1265cd3ab52a05ebc333e5dc79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color__group.html#ga5f19cd1265cd3ab52a05ebc333e5dc79">lab2rgb</a> (double l_, double a_, double b_, double &amp;r, double &amp;g, double &amp;b)</td></tr>
<tr class="memdesc:ga5f19cd1265cd3ab52a05ebc333e5dc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">L*a*b*色空間をRGB色空間に変換する  <a href="group__color__group.html#ga5f19cd1265cd3ab52a05ebc333e5dc79"></a><br/></td></tr>
<tr class="memitem:gae759de748e6a8e7e503e2b3f93d48a03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__endian__group.html#gae759de748e6a8e7e503e2b3f93d48a03">_is_little_endian_</a> ()</td></tr>
<tr class="memdesc:gae759de748e6a8e7e503e2b3f93d48a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在のマシンのエンディアンがリトルエンディアンかどうかを調べる  <a href="group__endian__group.html#gae759de748e6a8e7e503e2b3f93d48a03"></a><br/></td></tr>
<tr class="memitem:ga53141a1351836e135495bb28769bf43f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__endian__group.html#ga53141a1351836e135495bb28769bf43f">_is_big_endian_</a> ()</td></tr>
<tr class="memdesc:ga53141a1351836e135495bb28769bf43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在のマシンのエンディアンがビッグエンディアンかどうかを調べる  <a href="group__endian__group.html#ga53141a1351836e135495bb28769bf43f"></a><br/></td></tr>
<tr class="memitem:gac02114a7bc93baa61d52c12644a0f9ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac02114a7bc93baa61d52c12644a0f9ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__endian__group.html#gac02114a7bc93baa61d52c12644a0f9ee">swap_bytes</a> (<a class="el" href="unionmist_1_1byte__array.html">byte_array</a>&lt; T &gt; &amp;bytes)</td></tr>
<tr class="memdesc:gac02114a7bc93baa61d52c12644a0f9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte_array内のバイトスワップをする  <a href="group__endian__group.html#gac02114a7bc93baa61d52c12644a0f9ee"></a><br/></td></tr>
<tr class="memitem:gacb558bd66eaef6dcb3038d60e251eddc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacb558bd66eaef6dcb3038d60e251eddc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="unionmist_1_1byte__array.html">byte_array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__endian__group.html#gacb558bd66eaef6dcb3038d60e251eddc">to_current_endian</a> (const <a class="el" href="unionmist_1_1byte__array.html">byte_array</a>&lt; T &gt; &amp;bytes, bool from_little_endian)</td></tr>
<tr class="memdesc:gacb558bd66eaef6dcb3038d60e251eddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte_array内のデータを現在の計算機のエンディアンに合わせる  <a href="group__endian__group.html#gacb558bd66eaef6dcb3038d60e251eddc"></a><br/></td></tr>
<tr class="memitem:gaefdd026fc399aab67608954b7d06e8db"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaefdd026fc399aab67608954b7d06e8db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="unionmist_1_1byte__array.html">byte_array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__endian__group.html#gaefdd026fc399aab67608954b7d06e8db">from_current_endian</a> (const <a class="el" href="unionmist_1_1byte__array.html">byte_array</a>&lt; T &gt; &amp;bytes, bool to_little_endian)</td></tr>
<tr class="memdesc:gaefdd026fc399aab67608954b7d06e8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte_array内のデータを現在の計算機のエンディアンから目的のエンディアンに合わせる  <a href="group__endian__group.html#gaefdd026fc399aab67608954b7d06e8db"></a><br/></td></tr>
<tr class="memitem:a23294553d7540bd710c9ca4cd113680d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a23294553d7540bd710c9ca4cd113680d"></a>
template&lt;class T , class Distance , class Pointer , class Reference &gt; </td></tr>
<tr class="memitem:a23294553d7540bd710c9ca4cd113680d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, <br class="typebreak"/>
Distance, Pointer, Reference &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a23294553d7540bd710c9ca4cd113680d">operator+</a> (const <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, Distance, Pointer, Reference &gt; &amp;ite, typename <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, Distance, Pointer, Reference &gt;::difference_type dist)</td></tr>
<tr class="memdesc:a23294553d7540bd710c9ca4cd113680d"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ + 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:aaf8cd348159b8829fb5191840c0c15c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaf8cd348159b8829fb5191840c0c15c4"></a>
template&lt;class T , class Distance , class Pointer , class Reference &gt; </td></tr>
<tr class="memitem:aaf8cd348159b8829fb5191840c0c15c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, <br class="typebreak"/>
Distance, Pointer, Reference &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#aaf8cd348159b8829fb5191840c0c15c4">operator+</a> (typename <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, Distance, Pointer, Reference &gt;::difference_type dist, const <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, Distance, Pointer, Reference &gt; &amp;ite)</td></tr>
<tr class="memdesc:aaf8cd348159b8829fb5191840c0c15c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ + 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:a940a4e5dc24d977f8aff37b896ff8d8c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a940a4e5dc24d977f8aff37b896ff8d8c"></a>
template&lt;class T , class Distance , class Pointer , class Reference &gt; </td></tr>
<tr class="memitem:a940a4e5dc24d977f8aff37b896ff8d8c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, <br class="typebreak"/>
Distance, Pointer, Reference &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a940a4e5dc24d977f8aff37b896ff8d8c">operator-</a> (const <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, Distance, Pointer, Reference &gt; &amp;ite, typename <a class="el" href="classmist_1_1mist__iterator1.html">mist_iterator1</a>&lt; T, Distance, Pointer, Reference &gt;::difference_type dist)</td></tr>
<tr class="memdesc:a940a4e5dc24d977f8aff37b896ff8d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ - 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:a361d5f4d4fa4a0d6274526d023258a88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a361d5f4d4fa4a0d6274526d023258a88"></a>
template&lt;class T , class Distance , class Pointer , class Reference &gt; </td></tr>
<tr class="memitem:a361d5f4d4fa4a0d6274526d023258a88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, <br class="typebreak"/>
Distance, Pointer, Reference &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a361d5f4d4fa4a0d6274526d023258a88">operator+</a> (const <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, Distance, Pointer, Reference &gt; &amp;ite, typename <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, Distance, Pointer, Reference &gt;::difference_type dist)</td></tr>
<tr class="memdesc:a361d5f4d4fa4a0d6274526d023258a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ + 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:ab96e2625755b199a578a1ede27f25e1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab96e2625755b199a578a1ede27f25e1f"></a>
template&lt;class T , class Distance , class Pointer , class Reference &gt; </td></tr>
<tr class="memitem:ab96e2625755b199a578a1ede27f25e1f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, <br class="typebreak"/>
Distance, Pointer, Reference &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ab96e2625755b199a578a1ede27f25e1f">operator+</a> (typename <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, Distance, Pointer, Reference &gt;::difference_type dist, const <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, Distance, Pointer, Reference &gt; &amp;ite)</td></tr>
<tr class="memdesc:ab96e2625755b199a578a1ede27f25e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ + 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:ad249dd9f64f3ed8a505486e8390e08f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad249dd9f64f3ed8a505486e8390e08f2"></a>
template&lt;class T , class Distance , class Pointer , class Reference &gt; </td></tr>
<tr class="memitem:ad249dd9f64f3ed8a505486e8390e08f2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, <br class="typebreak"/>
Distance, Pointer, Reference &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ad249dd9f64f3ed8a505486e8390e08f2">operator-</a> (const <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, Distance, Pointer, Reference &gt; &amp;ite, typename <a class="el" href="classmist_1_1mist__iterator2.html">mist_iterator2</a>&lt; T, Distance, Pointer, Reference &gt;::difference_type dist)</td></tr>
<tr class="memdesc:ad249dd9f64f3ed8a505486e8390e08f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ - 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:a770865a33323d72685058aed6c7fd981"><td class="memTemplParams" colspan="2"><a class="anchor" id="a770865a33323d72685058aed6c7fd981"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a770865a33323d72685058aed6c7fd981"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a770865a33323d72685058aed6c7fd981">operator+</a> (const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt; &amp;ite1, const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt; ite2)</td></tr>
<tr class="memdesc:a770865a33323d72685058aed6c7fd981"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ + 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:a9f5c292642eca30375ad0b23aab0a779"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9f5c292642eca30375ad0b23aab0a779"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9f5c292642eca30375ad0b23aab0a779"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a9f5c292642eca30375ad0b23aab0a779">operator+</a> (const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt; &amp;ite, typename T::difference_type dist)</td></tr>
<tr class="memdesc:a9f5c292642eca30375ad0b23aab0a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ + 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:a61cc3e9ba6df1a58b732f816dee4cca2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61cc3e9ba6df1a58b732f816dee4cca2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a61cc3e9ba6df1a58b732f816dee4cca2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a61cc3e9ba6df1a58b732f816dee4cca2">operator+</a> (typename T::difference_type dist, const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt; &amp;ite)</td></tr>
<tr class="memdesc:a61cc3e9ba6df1a58b732f816dee4cca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ - 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:a3beec57a1aaf3bee3a49471cef1c0e87"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3beec57a1aaf3bee3a49471cef1c0e87"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3beec57a1aaf3bee3a49471cef1c0e87"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a3beec57a1aaf3bee3a49471cef1c0e87">operator-</a> (const <a class="el" href="classmist_1_1mist__reverse__iterator.html">mist_reverse_iterator</a>&lt; T &gt; &amp;ite, typename T::difference_type dist)</td></tr>
<tr class="memdesc:a3beec57a1aaf3bee3a49471cef1c0e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">dist だけ - 方向にイテレータを進めたイテレータを返す <br/></td></tr>
<tr class="memitem:a0bc34e9d99c662547e0a48b33ec93710"><td class="memTemplParams" colspan="2">template&lt;class Object1 , class Object2 &gt; </td></tr>
<tr class="memitem:a0bc34e9d99c662547e0a48b33ec93710"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a0bc34e9d99c662547e0a48b33ec93710">is_same_object</a> (const Object1 &amp;o1, const Object2 &amp;o2)</td></tr>
<tr class="memdesc:a0bc34e9d99c662547e0a48b33ec93710"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力された2つのオブジェクトが同じもの（メモリ上で同じ位置にある）かどうかを判定する  <a href="#a0bc34e9d99c662547e0a48b33ec93710"></a><br/></td></tr>
<tr class="memitem:ab2f799d2c98c030f7bc5ba23c8fb0380"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#ab2f799d2c98c030f7bc5ba23c8fb0380">wstr2str</a> (const std::wstring &amp;src)</td></tr>
<tr class="memdesc:ab2f799d2c98c030f7bc5ba23c8fb0380"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNICODE文字列をマルチバイト文字列に変換する  <a href="#ab2f799d2c98c030f7bc5ba23c8fb0380"></a><br/></td></tr>
<tr class="memitem:ad12f9a00a4f50f1aca5f71eb3818dff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#ad12f9a00a4f50f1aca5f71eb3818dff3">mist_debug_assertion</a> (ptrdiff_t index)</td></tr>
<tr class="memdesc:ad12f9a00a4f50f1aca5f71eb3818dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEBUGでMISTをビルドした際に，1次元アクセスでの範囲外アクセスをチェックし，エラーの際に呼ばれる関数．  <a href="#ad12f9a00a4f50f1aca5f71eb3818dff3"></a><br/></td></tr>
<tr class="memitem:aed63acbca1916d5d2df4b0462c10fcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#aed63acbca1916d5d2df4b0462c10fcc9">mist_debug_assertion</a> (ptrdiff_t index1, ptrdiff_t index2)</td></tr>
<tr class="memdesc:aed63acbca1916d5d2df4b0462c10fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEBUGでMISTをビルドした際に，2次元アクセスでの範囲外アクセスをチェックし，エラーの際に呼ばれる関数．  <a href="#aed63acbca1916d5d2df4b0462c10fcc9"></a><br/></td></tr>
<tr class="memitem:a96b299db390c5461be02f73c4394dc16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a96b299db390c5461be02f73c4394dc16">mist_debug_assertion</a> (ptrdiff_t index1, ptrdiff_t index2, ptrdiff_t index3)</td></tr>
<tr class="memdesc:a96b299db390c5461be02f73c4394dc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEBUGでMISTをビルドした際に，3次元アクセスでの範囲外アクセスをチェックし，エラーの際に呼ばれる関数．  <a href="#a96b299db390c5461be02f73c4394dc16"></a><br/></td></tr>
<tr class="memitem:gaf90e47036597033717e42b8286ccd5d3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf90e47036597033717e42b8286ccd5d3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pointer__group.html#gaf90e47036597033717e42b8286ccd5d3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:gaf90e47036597033717e42b8286ccd5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームにデータを出力する  <a href="group__pointer__group.html#gaf90e47036597033717e42b8286ccd5d3"></a><br/></td></tr>
<tr class="memitem:gaa2b4fcbf7a35c25fac85ca1c0602233b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa2b4fcbf7a35c25fac85ca1c0602233b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pointer__group.html#gaa2b4fcbf7a35c25fac85ca1c0602233b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1scoped__array.html">scoped_array</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:gaa2b4fcbf7a35c25fac85ca1c0602233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームにデータを出力する  <a href="group__pointer__group.html#gaa2b4fcbf7a35c25fac85ca1c0602233b"></a><br/></td></tr>
<tr class="memitem:ga75565937dcb5994322a042afaaaacd88"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga75565937dcb5994322a042afaaaacd88"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pointer__group.html#ga75565937dcb5994322a042afaaaacd88">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ga75565937dcb5994322a042afaaaacd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームにデータを出力する  <a href="group__pointer__group.html#ga75565937dcb5994322a042afaaaacd88"></a><br/></td></tr>
<tr class="memitem:ga03667d8703c1a984638bc5c6346a9fb9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga03667d8703c1a984638bc5c6346a9fb9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pointer__group.html#ga03667d8703c1a984638bc5c6346a9fb9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1weak__ptr.html">weak_ptr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ga03667d8703c1a984638bc5c6346a9fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームにデータを出力する  <a href="group__pointer__group.html#ga03667d8703c1a984638bc5c6346a9fb9"></a><br/></td></tr>
<tr class="memitem:ga06322ed48886892d5902d809d01c0068"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga06322ed48886892d5902d809d01c0068"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga06322ed48886892d5902d809d01c0068"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga06322ed48886892d5902d809d01c0068">operator+</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga06322ed48886892d5902d809d01c0068"><td class="mdescLeft">&#160;</td><td class="mdescRight">和集合を計算する <br/></td></tr>
<tr class="memitem:gab15a9902725eb6f47350a3b2e4186c92"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab15a9902725eb6f47350a3b2e4186c92"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:gab15a9902725eb6f47350a3b2e4186c92"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#gab15a9902725eb6f47350a3b2e4186c92">operator-</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:gab15a9902725eb6f47350a3b2e4186c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">差集合を計算する <br/></td></tr>
<tr class="memitem:ga69d97cb8a6f23ee9eb32667552bcfd79"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga69d97cb8a6f23ee9eb32667552bcfd79"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga69d97cb8a6f23ee9eb32667552bcfd79"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga69d97cb8a6f23ee9eb32667552bcfd79">operator*</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga69d97cb8a6f23ee9eb32667552bcfd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">積集合を計算する <br/></td></tr>
<tr class="memitem:gafc1f422107fa0c7bb70be2c08c9483b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="gafc1f422107fa0c7bb70be2c08c9483b6"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:gafc1f422107fa0c7bb70be2c08c9483b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#gafc1f422107fa0c7bb70be2c08c9483b6">operator*</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:gafc1f422107fa0c7bb70be2c08c9483b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合と1要素の積を計算する <br/></td></tr>
<tr class="memitem:gafb76172563692490fa686d1d695c1bd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="gafb76172563692490fa686d1d695c1bd6"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:gafb76172563692490fa686d1d695c1bd6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#gafb76172563692490fa686d1d695c1bd6">operator*</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:gafb76172563692490fa686d1d695c1bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">1要素と集合の積を計算する <br/></td></tr>
<tr class="memitem:gab0e51c7ad6168318e3fe73536920ecdf"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab0e51c7ad6168318e3fe73536920ecdf"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:gab0e51c7ad6168318e3fe73536920ecdf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#gab0e51c7ad6168318e3fe73536920ecdf">operator+</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:gab0e51c7ad6168318e3fe73536920ecdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合と1要素の和を計算する <br/></td></tr>
<tr class="memitem:ga6611c1f888810295bd766a06a5e690b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6611c1f888810295bd766a06a5e690b2"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga6611c1f888810295bd766a06a5e690b2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga6611c1f888810295bd766a06a5e690b2">operator+</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga6611c1f888810295bd766a06a5e690b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">1要素と集合の和を計算する <br/></td></tr>
<tr class="memitem:ga1236ce8d168bd02ffeec095b0da2222b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1236ce8d168bd02ffeec095b0da2222b"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga1236ce8d168bd02ffeec095b0da2222b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga1236ce8d168bd02ffeec095b0da2222b">operator-</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:ga1236ce8d168bd02ffeec095b0da2222b"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合と1要素の差を計算する <br/></td></tr>
<tr class="memitem:ga784b2cc7dbb331743b5a28362efd67f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga784b2cc7dbb331743b5a28362efd67f7"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga784b2cc7dbb331743b5a28362efd67f7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga784b2cc7dbb331743b5a28362efd67f7">operator-</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga784b2cc7dbb331743b5a28362efd67f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">1要素と集合の差を計算する <br/></td></tr>
<tr class="memitem:ga1a1d4bc7a3180b5c613ee7e98ed91279"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1a1d4bc7a3180b5c613ee7e98ed91279"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga1a1d4bc7a3180b5c613ee7e98ed91279"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga1a1d4bc7a3180b5c613ee7e98ed91279">operator==</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:ga1a1d4bc7a3180b5c613ee7e98ed91279"><td class="mdescLeft">&#160;</td><td class="mdescRight">全ての要素が等しいかどうかを判定する（ <img class="formulaInl" alt="$ a = b $" src="form_6.png"/>） <br/></td></tr>
<tr class="memitem:ga2c00257c63221a9baa708c81f1e0220f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2c00257c63221a9baa708c81f1e0220f"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga2c00257c63221a9baa708c81f1e0220f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga2c00257c63221a9baa708c81f1e0220f">operator!=</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:ga2c00257c63221a9baa708c81f1e0220f"><td class="mdescLeft">&#160;</td><td class="mdescRight">全ての要素が等しくないかどうかを判定する（ <img class="formulaInl" alt="$ a \neq b $" src="form_7.png"/>） <br/></td></tr>
<tr class="memitem:ga688b6637c85ba47f66a282aae3699e93"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga688b6637c85ba47f66a282aae3699e93"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga688b6637c85ba47f66a282aae3699e93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga688b6637c85ba47f66a282aae3699e93">operator&lt;</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:ga688b6637c85ba47f66a282aae3699e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \subset b $" src="form_8.png"/>） <br/></td></tr>
<tr class="memitem:ga2535b5deae46c41803b9c5d174be2279"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2535b5deae46c41803b9c5d174be2279"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga2535b5deae46c41803b9c5d174be2279"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga2535b5deae46c41803b9c5d174be2279">operator&lt;=</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:ga2535b5deae46c41803b9c5d174be2279"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \subseteq b $" src="form_9.png"/>） <br/></td></tr>
<tr class="memitem:gaf4a0ac17a1c50f007e44ab87b0ce5faa"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf4a0ac17a1c50f007e44ab87b0ce5faa"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:gaf4a0ac17a1c50f007e44ab87b0ce5faa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#gaf4a0ac17a1c50f007e44ab87b0ce5faa">operator&gt;</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:gaf4a0ac17a1c50f007e44ab87b0ce5faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \supset b $" src="form_10.png"/>） <br/></td></tr>
<tr class="memitem:ga9ac718114adefb48718af658a948d177"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9ac718114adefb48718af658a948d177"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga9ac718114adefb48718af658a948d177"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga9ac718114adefb48718af658a948d177">operator&gt;=</a> (const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s1, const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s2)</td></tr>
<tr class="memdesc:ga9ac718114adefb48718af658a948d177"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \supseteq b $" src="form_11.png"/>） <br/></td></tr>
<tr class="memitem:ga0ebcfe4308f8e55c358a42a961d0c880"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0ebcfe4308f8e55c358a42a961d0c880"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga0ebcfe4308f8e55c358a42a961d0c880"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga0ebcfe4308f8e55c358a42a961d0c880">operator==</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga0ebcfe4308f8e55c358a42a961d0c880"><td class="mdescLeft">&#160;</td><td class="mdescRight">全ての要素が等しいかどうかを判定する（ <img class="formulaInl" alt="$ a = b $" src="form_6.png"/>） <br/></td></tr>
<tr class="memitem:ga5efb853e43069d1ffaf3da310b623e39"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5efb853e43069d1ffaf3da310b623e39"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga5efb853e43069d1ffaf3da310b623e39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga5efb853e43069d1ffaf3da310b623e39">operator!=</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga5efb853e43069d1ffaf3da310b623e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">全ての要素が等しくないかどうかを判定する（ <img class="formulaInl" alt="$ a \neq b $" src="form_7.png"/>） <br/></td></tr>
<tr class="memitem:ga5811a9c72dd3196c8eb08389f0189278"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5811a9c72dd3196c8eb08389f0189278"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga5811a9c72dd3196c8eb08389f0189278"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga5811a9c72dd3196c8eb08389f0189278">operator&lt;</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga5811a9c72dd3196c8eb08389f0189278"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \subset b $" src="form_8.png"/>） <br/></td></tr>
<tr class="memitem:ga7dfb1ea482d6061dba23e97419638960"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7dfb1ea482d6061dba23e97419638960"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga7dfb1ea482d6061dba23e97419638960"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga7dfb1ea482d6061dba23e97419638960">operator&lt;=</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga7dfb1ea482d6061dba23e97419638960"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \subseteq b $" src="form_9.png"/>） <br/></td></tr>
<tr class="memitem:gada11f00312dc0bd8d251b06720a6bc2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="gada11f00312dc0bd8d251b06720a6bc2d"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:gada11f00312dc0bd8d251b06720a6bc2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#gada11f00312dc0bd8d251b06720a6bc2d">operator&gt;</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:gada11f00312dc0bd8d251b06720a6bc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \supset b $" src="form_10.png"/>） <br/></td></tr>
<tr class="memitem:ga5d6654cab5c1b7b0093d8f3503397cd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5d6654cab5c1b7b0093d8f3503397cd6"></a>
template&lt;class SetType &gt; </td></tr>
<tr class="memitem:ga5d6654cab5c1b7b0093d8f3503397cd6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#ga5d6654cab5c1b7b0093d8f3503397cd6">operator&gt;=</a> (const typename <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt;::key_type &amp;s1, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s2)</td></tr>
<tr class="memdesc:ga5d6654cab5c1b7b0093d8f3503397cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">集合の包含関係を調べる（ <img class="formulaInl" alt="$ a \supseteq b $" src="form_11.png"/>） <br/></td></tr>
<tr class="memitem:gab02391403e887634fea70224580c9694"><td class="memTemplParams" colspan="2">template&lt;class SetType &gt; </td></tr>
<tr class="memitem:gab02391403e887634fea70224580c9694"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__group.html#gab02391403e887634fea70224580c9694">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1set__base.html">set_base</a>&lt; SetType &gt; &amp;s)</td></tr>
<tr class="memdesc:gab02391403e887634fea70224580c9694"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__set__group.html#gab02391403e887634fea70224580c9694"></a><br/></td></tr>
<tr class="memitem:a39980026a4d55f5bb3a12c0684f2dc72"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a39980026a4d55f5bb3a12c0684f2dc72"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a39980026a4d55f5bb3a12c0684f2dc72">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structmist_1_1stereo.html">stereo</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a39980026a4d55f5bb3a12c0684f2dc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">ステレオ音声データの和  <a href="#a39980026a4d55f5bb3a12c0684f2dc72"></a><br/></td></tr>
<tr class="memitem:ga0106393335685307f2dc94e85957743b"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga0106393335685307f2dc94e85957743b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__converter__group.html#ga0106393335685307f2dc94e85957743b">convert</a> (const Array1 &amp;in, Array2 &amp;out)</td></tr>
<tr class="memdesc:ga0106393335685307f2dc94e85957743b"><td class="mdescLeft">&#160;</td><td class="mdescRight">あるMISTコンテナから他のコンテナへの変換  <a href="group__image__converter__group.html#ga0106393335685307f2dc94e85957743b"></a><br/></td></tr>
<tr class="memitem:ga41301cb16d180b6477d6df33b3d0391b"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga41301cb16d180b6477d6df33b3d0391b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__draw__group.html#ga41301cb16d180b6477d6df33b3d0391b">draw_buffer</a> (const Array &amp;image, typename Array::size_type image_width, typename Array::size_type image_height, typename Array::size_type window_width, typename Array::size_type window_height, double zoom=1.0, double xpos=0.0, double ypos=0.0, bool <a class="el" href="namespacemist.html#a416c4e90fbe4e1ecb13ea585d80a77b2">interpolate</a>=true)</td></tr>
<tr class="memdesc:ga41301cb16d180b6477d6df33b3d0391b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像をOpenGLを用いてウィンドウに描画する  <a href="group__image__draw__group.html#ga41301cb16d180b6477d6df33b3d0391b"></a><br/></td></tr>
<tr class="memitem:ga50420a9b668fee543c580ed44d93f8fe"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga50420a9b668fee543c580ed44d93f8fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__draw__group.html#ga50420a9b668fee543c580ed44d93f8fe">draw_image</a> (const Array &amp;image, typename Array::size_type window_width, typename Array::size_type window_height, double zoom=1.0, double xpos=0.0, double ypos=0.0, double back_r=0.0, double back_g=0.0, double back_b=0.0, bool <a class="el" href="namespacemist.html#a416c4e90fbe4e1ecb13ea585d80a77b2">interpolate</a>=true, bool blend=false)</td></tr>
<tr class="memdesc:ga50420a9b668fee543c580ed44d93f8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像をOpenGLを用いてウィンドウに描画する  <a href="group__image__draw__group.html#ga50420a9b668fee543c580ed44d93f8fe"></a><br/></td></tr>
<tr class="memitem:ga79ddde040455f3bfc08ffb1258a49349"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga79ddde040455f3bfc08ffb1258a49349"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__draw__group.html#ga79ddde040455f3bfc08ffb1258a49349">draw_pixels</a> (const Array &amp;image, typename Array::size_type window_width, typename Array::size_type window_height, typename Array::difference_type xpos=0, typename Array::difference_type ypos=0, bool blend=false)</td></tr>
<tr class="memdesc:ga79ddde040455f3bfc08ffb1258a49349"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像をOpenGLを用いてウィンドウに描画する  <a href="group__image__draw__group.html#ga79ddde040455f3bfc08ffb1258a49349"></a><br/></td></tr>
<tr class="memitem:gac4d706f551b839fb7619c8c3c5c43a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__draw__group.html#gac4d706f551b839fb7619c8c3c5c43a55">screen2point</a> (const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; double &gt; &amp;pt, double imgX, double imgY, double aspect, double winW, double winH, double zoom, double posx, double posy)</td></tr>
<tr class="memdesc:gac4d706f551b839fb7619c8c3c5c43a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">ウィンドウ座標系の点を画像座標系の点に変換する  <a href="group__image__draw__group.html#gac4d706f551b839fb7619c8c3c5c43a55"></a><br/></td></tr>
<tr class="memitem:gafd46aa022954b5b5b7511d078a60e6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__draw__group.html#gafd46aa022954b5b5b7511d078a60e6a3">point2screen</a> (const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; double &gt; &amp;pt, double imgX, double imgY, double aspect, double winW, double winH, double zoom, double posx, double posy)</td></tr>
<tr class="memdesc:gafd46aa022954b5b5b7511d078a60e6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像座標系の点をウィンドウ座標系の点に変換する  <a href="group__image__draw__group.html#gafd46aa022954b5b5b7511d078a60e6a3"></a><br/></td></tr>
<tr class="memitem:gac05c5144a880d8c906c4c8ff7da6b20a"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gac05c5144a880d8c906c4c8ff7da6b20a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#gac05c5144a880d8c906c4c8ff7da6b20a">draw_line</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x1, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y1, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x2, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y2, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type <a class="el" href="structmist_1_1color.html">color</a>=typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type())</td></tr>
<tr class="memdesc:gac05c5144a880d8c906c4c8ff7da6b20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像に直線を描画する  <a href="group__image__drawing__group.html#gac05c5144a880d8c906c4c8ff7da6b20a"></a><br/></td></tr>
<tr class="memitem:gab056912502eb829eefdd638457c952da"><td class="memTemplParams" colspan="2">template&lt;size_t BITS&gt; </td></tr>
<tr class="memitem:gab056912502eb829eefdd638457c952da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#gab056912502eb829eefdd638457c952da">draw_line</a> (<a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS &gt; &amp;image, typename <a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS &gt;::difference_type x1, typename <a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS &gt;::difference_type y1, typename <a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS &gt;::difference_type x2, typename <a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS &gt;::difference_type y2, typename <a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS &gt;::value_type <a class="el" href="structmist_1_1color.html">color</a>=typename <a class="el" href="classmist_1_1bitmap.html">bitmap</a>&lt; BITS &gt;::value_type())</td></tr>
<tr class="memdesc:gab056912502eb829eefdd638457c952da"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元ビットマップ画像に直線を描画する  <a href="group__image__drawing__group.html#gab056912502eb829eefdd638457c952da"></a><br/></td></tr>
<tr class="memitem:gaccae97a740521f81015a58ee12a1118f"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaccae97a740521f81015a58ee12a1118f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#gaccae97a740521f81015a58ee12a1118f">draw_line</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type x1, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type y1, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type z1, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type x2, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type y2, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type z2, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type <a class="el" href="structmist_1_1color.html">color</a>=typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type())</td></tr>
<tr class="memdesc:gaccae97a740521f81015a58ee12a1118f"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に直線を描画する  <a href="group__image__drawing__group.html#gaccae97a740521f81015a58ee12a1118f"></a><br/></td></tr>
<tr class="memitem:ga6326e1479ee096157cb1aaa5dbe5f5ad"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga6326e1479ee096157cb1aaa5dbe5f5ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#ga6326e1479ee096157cb1aaa5dbe5f5ad">draw_point</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type radius, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type value=typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type())</td></tr>
<tr class="memdesc:ga6326e1479ee096157cb1aaa5dbe5f5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に直線を描画する  <a href="group__image__drawing__group.html#ga6326e1479ee096157cb1aaa5dbe5f5ad"></a><br/></td></tr>
<tr class="memitem:ga01c4bc5857d31c2414a26010f5d3689a"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga01c4bc5857d31c2414a26010f5d3689a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#ga01c4bc5857d31c2414a26010f5d3689a">draw_point</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type x, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type y, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type z, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::difference_type radius, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type value=typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type())</td></tr>
<tr class="memdesc:ga01c4bc5857d31c2414a26010f5d3689a"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に直線を描画する  <a href="group__image__drawing__group.html#ga01c4bc5857d31c2414a26010f5d3689a"></a><br/></td></tr>
<tr class="memitem:gaa5444e3c1a7d080b02419c8e88edadc2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa5444e3c1a7d080b02419c8e88edadc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#gaa5444e3c1a7d080b02419c8e88edadc2">set_pixel</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y, const typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type &amp;value)</td></tr>
<tr class="memdesc:gaa5444e3c1a7d080b02419c8e88edadc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元が像に範囲チェックを行い，値を代入  <a href="group__image__drawing__group.html#gaa5444e3c1a7d080b02419c8e88edadc2"></a><br/></td></tr>
<tr class="memitem:ga383e43a231283f53ec00c31ca7ae5422"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:ga383e43a231283f53ec00c31ca7ae5422"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#ga383e43a231283f53ec00c31ca7ae5422">draw_circle</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type cx, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type cy, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type r, const typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type &amp;value)</td></tr>
<tr class="memdesc:ga383e43a231283f53ec00c31ca7ae5422"><td class="mdescLeft">&#160;</td><td class="mdescRight">円を描く(Michenerの手法)  <a href="group__image__drawing__group.html#ga383e43a231283f53ec00c31ca7ae5422"></a><br/></td></tr>
<tr class="memitem:ga7eb76ce94f3fa74f90a243923270f1d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:ga7eb76ce94f3fa74f90a243923270f1d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#ga7eb76ce94f3fa74f90a243923270f1d8">draw_rect</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x0, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y0, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x1, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y1, const typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type &amp;value)</td></tr>
<tr class="memdesc:ga7eb76ce94f3fa74f90a243923270f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">長方形を描く  <a href="group__image__drawing__group.html#ga7eb76ce94f3fa74f90a243923270f1d8"></a><br/></td></tr>
<tr class="memitem:ga5d342a5956db1b56347c07a4c0f3d512"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:ga5d342a5956db1b56347c07a4c0f3d512"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#ga5d342a5956db1b56347c07a4c0f3d512">fill_rect</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x0, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y0, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type x1, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type y1, const typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type &amp;value)</td></tr>
<tr class="memdesc:ga5d342a5956db1b56347c07a4c0f3d512"><td class="mdescLeft">&#160;</td><td class="mdescRight">長方形で塗りつぶす  <a href="group__image__drawing__group.html#ga5d342a5956db1b56347c07a4c0f3d512"></a><br/></td></tr>
<tr class="memitem:gaa8e95b8667b2a451eb349bd209571828"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa8e95b8667b2a451eb349bd209571828"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__drawing__group.html#gaa8e95b8667b2a451eb349bd209571828">draw_crosspoint</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type cx, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type cy, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type size, const typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type &amp;value)</td></tr>
<tr class="memdesc:gaa8e95b8667b2a451eb349bd209571828"><td class="mdescLeft">&#160;</td><td class="mdescRight">十字点を描画  <a href="group__image__drawing__group.html#gaa8e95b8667b2a451eb349bd209571828"></a><br/></td></tr>
<tr class="memitem:gaa1482f4ec8ec4adf25e01697fd7f1973"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gaa1482f4ec8ec4adf25e01697fd7f1973">os</a> ()</td></tr>
<tr class="memdesc:gaa1482f4ec8ec4adf25e01697fd7f1973"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS情報を返す関数  <a href="group__environment__group.html#gaa1482f4ec8ec4adf25e01697fd7f1973"></a><br/></td></tr>
<tr class="memitem:gabf4166aa94fbb3bdaf8633e7099e087b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gabf4166aa94fbb3bdaf8633e7099e087b">cpu</a> ()</td></tr>
<tr class="memdesc:gabf4166aa94fbb3bdaf8633e7099e087b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU名を返す関数  <a href="group__environment__group.html#gabf4166aa94fbb3bdaf8633e7099e087b"></a><br/></td></tr>
<tr class="memitem:gae7ac31119c22ac2f90ef8bb239a63ab1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gae7ac31119c22ac2f90ef8bb239a63ab1">cpu_num</a> ()</td></tr>
<tr class="memdesc:gae7ac31119c22ac2f90ef8bb239a63ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU数を返す関数  <a href="group__environment__group.html#gae7ac31119c22ac2f90ef8bb239a63ab1"></a><br/></td></tr>
<tr class="memitem:gaf5e67d2b51d47464982bf91e1325073d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gaf5e67d2b51d47464982bf91e1325073d">machine</a> ()</td></tr>
<tr class="memdesc:gaf5e67d2b51d47464982bf91e1325073d"><td class="mdescLeft">&#160;</td><td class="mdescRight">計算機名を返す関数  <a href="group__environment__group.html#gaf5e67d2b51d47464982bf91e1325073d"></a><br/></td></tr>
<tr class="memitem:gaf543ada8a920cc286fc5b3cbeab099ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__environment__group.html#gaf543ada8a920cc286fc5b3cbeab099ef">user</a> ()</td></tr>
<tr class="memdesc:gaf543ada8a920cc286fc5b3cbeab099ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在のユーザー名を返す関数  <a href="group__environment__group.html#gaf543ada8a920cc286fc5b3cbeab099ef"></a><br/></td></tr>
<tr class="memitem:gafdb210f6eea7c49dbdde725ad97c161f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gafdb210f6eea7c49dbdde725ad97c161f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__facet__group.html#gafdb210f6eea7c49dbdde725ad97c161f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1facet.html">facet</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:gafdb210f6eea7c49dbdde725ad97c161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，ポリゴンオブジェクトを整形して出力する  <a href="group__facet__group.html#gafdb210f6eea7c49dbdde725ad97c161f"></a><br/></td></tr>
<tr class="memitem:gaeeaa0e1c6ffe913f8992308642ee8858"><td class="memTemplParams" colspan="2">template&lt;class T , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:gaeeaa0e1c6ffe913f8992308642ee8858"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__facet__group.html#gaeeaa0e1c6ffe913f8992308642ee8858">convert_to_vertex_face_list</a> (const <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, std::vector&lt; <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T1 &gt; &gt; &amp;vertices, std::vector&lt; <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T2 &gt; &gt; &amp;faces, const double eps=1.0e-6)</td></tr>
<tr class="memdesc:gaeeaa0e1c6ffe913f8992308642ee8858"><td class="mdescLeft">&#160;</td><td class="mdescRight">3角形パッチの集合から頂点集合と三角形パッチを構成するインデックス集合に変換する  <a href="group__facet__group.html#gaeeaa0e1c6ffe913f8992308642ee8858"></a><br/></td></tr>
<tr class="memitem:ga7b71d3f3a684e8073fbcdef04bf5a641"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7b71d3f3a684e8073fbcdef04bf5a641"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__facet__group.html#ga7b71d3f3a684e8073fbcdef04bf5a641">surface_simplification</a> (<a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, size_t number_of_facets, bool use_optimal_vertex_placement=true, double threshold_for_triangle_compactness=0.0, const double eps=1.0e-3)</td></tr>
<tr class="memdesc:ga7b71d3f3a684e8073fbcdef04bf5a641"><td class="mdescLeft">&#160;</td><td class="mdescRight">3角形パッチの集合から頂点集合と三角形パッチを構成するインデックス集合に変換する  <a href="group__facet__group.html#ga7b71d3f3a684e8073fbcdef04bf5a641"></a><br/></td></tr>
<tr class="memitem:gae5dc8e22e523fe969bb213257e05449d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae5dc8e22e523fe969bb213257e05449d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__facet__group.html#gae5dc8e22e523fe969bb213257e05449d">maximum_connected_region</a> (<a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const double eps=1.0e-3)</td></tr>
<tr class="memdesc:gae5dc8e22e523fe969bb213257e05449d"><td class="mdescLeft">&#160;</td><td class="mdescRight">3角形パッチの集合から最大の連結領域のみを取り出し，他を全て削除する  <a href="group__facet__group.html#gae5dc8e22e523fe969bb213257e05449d"></a><br/></td></tr>
<tr class="memitem:ga44a5e3b7768c1caf46f4f28f56478973"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga44a5e3b7768c1caf46f4f28f56478973"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dct__group.html#ga44a5e3b7768c1caf46f4f28f56478973">dct</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga44a5e3b7768c1caf46f4f28f56478973"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元高速コサイン変換  <a href="group__dct__group.html#ga44a5e3b7768c1caf46f4f28f56478973"></a><br/></td></tr>
<tr class="memitem:gab5af9a67045a653b0f899c2aee50089b"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gab5af9a67045a653b0f899c2aee50089b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dct__group.html#gab5af9a67045a653b0f899c2aee50089b">idct</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:gab5af9a67045a653b0f899c2aee50089b"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元高速コサイン逆変換  <a href="group__dct__group.html#gab5af9a67045a653b0f899c2aee50089b"></a><br/></td></tr>
<tr class="memitem:ga980a33e81d05cefda74199dd6f60fa20"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga980a33e81d05cefda74199dd6f60fa20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dct__group.html#ga980a33e81d05cefda74199dd6f60fa20">dct</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga980a33e81d05cefda74199dd6f60fa20"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元高速コサイン変換  <a href="group__dct__group.html#ga980a33e81d05cefda74199dd6f60fa20"></a><br/></td></tr>
<tr class="memitem:gae848441f1a5a337894da7279d1b69a9d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gae848441f1a5a337894da7279d1b69a9d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dct__group.html#gae848441f1a5a337894da7279d1b69a9d">idct</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:gae848441f1a5a337894da7279d1b69a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元高速コサイン逆変換  <a href="group__dct__group.html#gae848441f1a5a337894da7279d1b69a9d"></a><br/></td></tr>
<tr class="memitem:gaada0a0f1f12d2b0a8a7a3a2483e48dd9"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gaada0a0f1f12d2b0a8a7a3a2483e48dd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dct__group.html#gaada0a0f1f12d2b0a8a7a3a2483e48dd9">dct</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:gaada0a0f1f12d2b0a8a7a3a2483e48dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元高速コサイン変換  <a href="group__dct__group.html#gaada0a0f1f12d2b0a8a7a3a2483e48dd9"></a><br/></td></tr>
<tr class="memitem:gafd69c9250a4c585c213138a861dbdd16"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gafd69c9250a4c585c213138a861dbdd16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dct__group.html#gafd69c9250a4c585c213138a861dbdd16">idct</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:gafd69c9250a4c585c213138a861dbdd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元高速コサイン逆変換  <a href="group__dct__group.html#gafd69c9250a4c585c213138a861dbdd16"></a><br/></td></tr>
<tr class="memitem:ga2b34d712ac7c0b9ad9ad3f974134a762"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga2b34d712ac7c0b9ad9ad3f974134a762"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dst__group.html#ga2b34d712ac7c0b9ad9ad3f974134a762">dst</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga2b34d712ac7c0b9ad9ad3f974134a762"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元高速サイン変換  <a href="group__dst__group.html#ga2b34d712ac7c0b9ad9ad3f974134a762"></a><br/></td></tr>
<tr class="memitem:ga26032d736da001916490fc6998d83d7d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga26032d736da001916490fc6998d83d7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dst__group.html#ga26032d736da001916490fc6998d83d7d">idst</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga26032d736da001916490fc6998d83d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元高速サイン逆変換  <a href="group__dst__group.html#ga26032d736da001916490fc6998d83d7d"></a><br/></td></tr>
<tr class="memitem:gaa06a88453dac85377ccd485bc0a52250"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gaa06a88453dac85377ccd485bc0a52250"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dst__group.html#gaa06a88453dac85377ccd485bc0a52250">dst</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:gaa06a88453dac85377ccd485bc0a52250"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元高速サイン変換  <a href="group__dst__group.html#gaa06a88453dac85377ccd485bc0a52250"></a><br/></td></tr>
<tr class="memitem:ga10bf60abb0c1921c2bb363b82ac89d87"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga10bf60abb0c1921c2bb363b82ac89d87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dst__group.html#ga10bf60abb0c1921c2bb363b82ac89d87">idst</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga10bf60abb0c1921c2bb363b82ac89d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元高速サイン逆変換  <a href="group__dst__group.html#ga10bf60abb0c1921c2bb363b82ac89d87"></a><br/></td></tr>
<tr class="memitem:ga70b037735a3523343dd6e24722775303"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga70b037735a3523343dd6e24722775303"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dst__group.html#ga70b037735a3523343dd6e24722775303">dst</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga70b037735a3523343dd6e24722775303"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元高速サイン変換  <a href="group__dst__group.html#ga70b037735a3523343dd6e24722775303"></a><br/></td></tr>
<tr class="memitem:ga2d27bb907ddc393ac914e95f22caffab"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga2d27bb907ddc393ac914e95f22caffab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dst__group.html#ga2d27bb907ddc393ac914e95f22caffab">idst</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga2d27bb907ddc393ac914e95f22caffab"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元高速サイン逆変換  <a href="group__dst__group.html#ga2d27bb907ddc393ac914e95f22caffab"></a><br/></td></tr>
<tr class="memitem:ga6d5c0e7f1b527cdb6d1e5ed4ea08fe32"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga6d5c0e7f1b527cdb6d1e5ed4ea08fe32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft__group.html#ga6d5c0e7f1b527cdb6d1e5ed4ea08fe32">fft</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga6d5c0e7f1b527cdb6d1e5ed4ea08fe32"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元高速フーリエ変換  <a href="group__fft__group.html#ga6d5c0e7f1b527cdb6d1e5ed4ea08fe32"></a><br/></td></tr>
<tr class="memitem:ga953311489527890425e38766a9995eb4"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga953311489527890425e38766a9995eb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft__group.html#ga953311489527890425e38766a9995eb4">ifft</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga953311489527890425e38766a9995eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">1次元高速逆フーリエ変換  <a href="group__fft__group.html#ga953311489527890425e38766a9995eb4"></a><br/></td></tr>
<tr class="memitem:ga107d069c519780f194df0a7c93e52511"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga107d069c519780f194df0a7c93e52511"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft__group.html#ga107d069c519780f194df0a7c93e52511">fft</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga107d069c519780f194df0a7c93e52511"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元高速フーリエ変換  <a href="group__fft__group.html#ga107d069c519780f194df0a7c93e52511"></a><br/></td></tr>
<tr class="memitem:ga439af1a554c441934f03df5cb2a32bd2"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga439af1a554c441934f03df5cb2a32bd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft__group.html#ga439af1a554c441934f03df5cb2a32bd2">ifft</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga439af1a554c441934f03df5cb2a32bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元高速逆フーリエ変換  <a href="group__fft__group.html#ga439af1a554c441934f03df5cb2a32bd2"></a><br/></td></tr>
<tr class="memitem:ga30f39ef010f005266cbae422cb963f8d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga30f39ef010f005266cbae422cb963f8d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft__group.html#ga30f39ef010f005266cbae422cb963f8d">fft</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:ga30f39ef010f005266cbae422cb963f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元高速フーリエ変換  <a href="group__fft__group.html#ga30f39ef010f005266cbae422cb963f8d"></a><br/></td></tr>
<tr class="memitem:gad3c2e6b5a4199c1d4fc7422f67566a48"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gad3c2e6b5a4199c1d4fc7422f67566a48"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft__group.html#gad3c2e6b5a4199c1d4fc7422f67566a48">ifft</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:gad3c2e6b5a4199c1d4fc7422f67566a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元高速逆フーリエ変換  <a href="group__fft__group.html#gad3c2e6b5a4199c1d4fc7422f67566a48"></a><br/></td></tr>
<tr class="memitem:ga8eff5c61a01d7521b7b5a9b2644a1ebb"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga8eff5c61a01d7521b7b5a9b2644a1ebb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#ga8eff5c61a01d7521b7b5a9b2644a1ebb">boundary4</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type inside, bool boundary_is_border, Functor f)</td></tr>
<tr class="memdesc:ga8eff5c61a01d7521b7b5a9b2644a1ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と4近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#ga8eff5c61a01d7521b7b5a9b2644a1ebb"></a><br/></td></tr>
<tr class="memitem:ga8ac91088df808f135c8d8870259dc90c"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga8ac91088df808f135c8d8870259dc90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#ga8ac91088df808f135c8d8870259dc90c">boundary4</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type inside=0, bool boundary_is_border=true)</td></tr>
<tr class="memdesc:ga8ac91088df808f135c8d8870259dc90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と4近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#ga8ac91088df808f135c8d8870259dc90c"></a><br/></td></tr>
<tr class="memitem:ga72bd215941ecfaecf21ea1d8075dbd38"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga72bd215941ecfaecf21ea1d8075dbd38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#ga72bd215941ecfaecf21ea1d8075dbd38">boundary8</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type inside, bool boundary_is_border, Functor f)</td></tr>
<tr class="memdesc:ga72bd215941ecfaecf21ea1d8075dbd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と8近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#ga72bd215941ecfaecf21ea1d8075dbd38"></a><br/></td></tr>
<tr class="memitem:gaa7cc8f4191197d39d25f3c51b2209a7b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaa7cc8f4191197d39d25f3c51b2209a7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#gaa7cc8f4191197d39d25f3c51b2209a7b">boundary8</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type inside=0, bool boundary_is_border=true)</td></tr>
<tr class="memdesc:gaa7cc8f4191197d39d25f3c51b2209a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と8近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#gaa7cc8f4191197d39d25f3c51b2209a7b"></a><br/></td></tr>
<tr class="memitem:ga7d6273c62e5bcca1eec03be9ffb7a666"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga7d6273c62e5bcca1eec03be9ffb7a666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#ga7d6273c62e5bcca1eec03be9ffb7a666">boundary6</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type inside, bool boundary_is_border, Functor f)</td></tr>
<tr class="memdesc:ga7d6273c62e5bcca1eec03be9ffb7a666"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と6近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#ga7d6273c62e5bcca1eec03be9ffb7a666"></a><br/></td></tr>
<tr class="memitem:ga3271b015cfbd2becd92b9a6720af27bd"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga3271b015cfbd2becd92b9a6720af27bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#ga3271b015cfbd2becd92b9a6720af27bd">boundary6</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type inside=0, bool boundary_is_border=true)</td></tr>
<tr class="memdesc:ga3271b015cfbd2becd92b9a6720af27bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と6近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#ga3271b015cfbd2becd92b9a6720af27bd"></a><br/></td></tr>
<tr class="memitem:gada0f64d016f55345ce7366d2ebc0d8e1"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:gada0f64d016f55345ce7366d2ebc0d8e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#gada0f64d016f55345ce7366d2ebc0d8e1">boundary18</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type inside, bool boundary_is_border, Functor f)</td></tr>
<tr class="memdesc:gada0f64d016f55345ce7366d2ebc0d8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と18近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#gada0f64d016f55345ce7366d2ebc0d8e1"></a><br/></td></tr>
<tr class="memitem:ga78e166ec40add3bd8655da2401fb303b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga78e166ec40add3bd8655da2401fb303b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#ga78e166ec40add3bd8655da2401fb303b">boundary18</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type inside=0, bool boundary_is_border=true)</td></tr>
<tr class="memdesc:ga78e166ec40add3bd8655da2401fb303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と18近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#ga78e166ec40add3bd8655da2401fb303b"></a><br/></td></tr>
<tr class="memitem:gac60f8005d9f1a771b53f1e4250721141"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:gac60f8005d9f1a771b53f1e4250721141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#gac60f8005d9f1a771b53f1e4250721141">boundary26</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type inside, bool boundary_is_border, Functor f)</td></tr>
<tr class="memdesc:gac60f8005d9f1a771b53f1e4250721141"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と26近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#gac60f8005d9f1a771b53f1e4250721141"></a><br/></td></tr>
<tr class="memitem:ga76c01807f3477fd21c19f6ac6232ec7d"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga76c01807f3477fd21c19f6ac6232ec7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary__group.html#ga76c01807f3477fd21c19f6ac6232ec7d">boundary26</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type border, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type inside=0, bool boundary_is_border=true)</td></tr>
<tr class="memdesc:ga76c01807f3477fd21c19f6ac6232ec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景と18近傍で接する境界画素を抽出する  <a href="group__boundary__group.html#ga76c01807f3477fd21c19f6ac6232ec7d"></a><br/></td></tr>
<tr class="memitem:ga5024b59625782787fcfcb492d8e893f1"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , template&lt; typename, typename &gt; class LIST, class TT , class AAllocator &gt; </td></tr>
<tr class="memitem:ga5024b59625782787fcfcb492d8e893f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__corner__group.html#ga5024b59625782787fcfcb492d8e893f1">harris</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, LIST&lt; <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; TT &gt;, AAllocator &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type max_corners, double min_distance, double kappa=0.04, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type window_size=3)</td></tr>
<tr class="memdesc:ga5024b59625782787fcfcb492d8e893f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harrisのコーナー検出フィルタ  <a href="group__corner__group.html#ga5024b59625782787fcfcb492d8e893f1"></a><br/></td></tr>
<tr class="memitem:gacbb7810e4010bb9b2ce368d2295e351d"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Functor &gt; </td></tr>
<tr class="memitem:gacbb7810e4010bb9b2ce368d2295e351d"><td class="memTemplItemLeft" align="right" valign="top">Array1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__decomposition__group.html#gacbb7810e4010bb9b2ce368d2295e351d">figure_decomposition</a> (const Array1 &amp;in, Array2 &amp;out, double max_distance, Functor f)</td></tr>
<tr class="memdesc:gacbb7810e4010bb9b2ce368d2295e351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユークリッド距離に基づく図形分割  <a href="group__decomposition__group.html#gacbb7810e4010bb9b2ce368d2295e351d"></a><br/></td></tr>
<tr class="memitem:ga9260c265b84c8a0d2ee1c09050d33377"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga9260c265b84c8a0d2ee1c09050d33377"><td class="memTemplItemLeft" align="right" valign="top">Array1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__decomposition__group.html#ga9260c265b84c8a0d2ee1c09050d33377">figure_decomposition</a> (const Array1 &amp;in, Array2 &amp;out, double max_distance=-1)</td></tr>
<tr class="memdesc:ga9260c265b84c8a0d2ee1c09050d33377"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユークリッド距離に基づく図形分割  <a href="group__decomposition__group.html#ga9260c265b84c8a0d2ee1c09050d33377"></a><br/></td></tr>
<tr class="memitem:ga09c94de055341e993e336cf60648a361"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga09c94de055341e993e336cf60648a361"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__skeleton__group.html#ga09c94de055341e993e336cf60648a361">skeleton</a> (const Array1 &amp;in, Array2 &amp;out)</td></tr>
<tr class="memdesc:ga09c94de055341e993e336cf60648a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユークリッド2乗距離画像を入力とするスケルトン抽出  <a href="group__skeleton__group.html#ga09c94de055341e993e336cf60648a361"></a><br/></td></tr>
<tr class="memitem:ga28a5402c2799df009c0cfee3cb5cb2ce"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga28a5402c2799df009c0cfee3cb5cb2ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__edge__group.html#ga28a5402c2799df009c0cfee3cb5cb2ce">canny</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, double lower, double upper, bool useL2gradient=false, const typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::value_type &amp;fgval=typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::value_type(255), const typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::value_type &amp;bgval=typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::value_type(0), typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga28a5402c2799df009c0cfee3cb5cb2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cannyのエッジ検出フィルタ  <a href="group__edge__group.html#ga28a5402c2799df009c0cfee3cb5cb2ce"></a><br/></td></tr>
<tr class="memitem:ga94c17247408f52295a63372369cc03f1"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Fusion &gt; </td></tr>
<tr class="memitem:ga94c17247408f52295a63372369cc03f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fusion__group.html#ga94c17247408f52295a63372369cc03f1">fusion</a> (const Array1 &amp;in, Array2 &amp;out, typename Array1::size_type length, typename Array1::size_type thread_num, Fusion fusion)</td></tr>
<tr class="memdesc:ga94c17247408f52295a63372369cc03f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の距離タイプに対応した図形融合  <a href="group__fusion__group.html#ga94c17247408f52295a63372369cc03f1"></a><br/></td></tr>
<tr class="memitem:ga7edf68f76cf06e0444f1a5f7186a58b7"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga7edf68f76cf06e0444f1a5f7186a58b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fusion__mdt__group.html#ga7edf68f76cf06e0444f1a5f7186a58b7">expand_mdt</a> (const Array1 &amp;in, Array2 &amp;out, typename Array1::size_type length=1, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga7edf68f76cf06e0444f1a5f7186a58b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">マンハッタン距離（L1ノルム，シティーブロック距離）タイプの図形拡大  <a href="group__fusion__mdt__group.html#ga7edf68f76cf06e0444f1a5f7186a58b7"></a><br/></td></tr>
<tr class="memitem:ga911a118d8989a1f3ed81e9062dd348da"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga911a118d8989a1f3ed81e9062dd348da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fusion__mdt__group.html#ga911a118d8989a1f3ed81e9062dd348da">shrink_mdt</a> (const Array1 &amp;in, Array2 &amp;out, typename Array1::size_type length=1, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga911a118d8989a1f3ed81e9062dd348da"><td class="mdescLeft">&#160;</td><td class="mdescRight">マンハッタン距離（L1ノルム，シティーブロック距離）タイプの図形縮小  <a href="group__fusion__mdt__group.html#ga911a118d8989a1f3ed81e9062dd348da"></a><br/></td></tr>
<tr class="memitem:ga364a727ba4aeb449a5baa42b3c61cb21"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga364a727ba4aeb449a5baa42b3c61cb21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__interlace__group.html#ga364a727ba4aeb449a5baa42b3c61cb21">interlace</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;out, bool is_odd_line=false, bool is_row_interlace=true)</td></tr>
<tr class="memdesc:ga364a727ba4aeb449a5baa42b3c61cb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像のインターレス除去を行う  <a href="group__interlace__group.html#ga364a727ba4aeb449a5baa42b3c61cb21"></a><br/></td></tr>
<tr class="memitem:ga4525d91ad64550cb609f29c1943e78fc"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 , class Functor &gt; </td></tr>
<tr class="memitem:ga4525d91ad64550cb609f29c1943e78fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga4525d91ad64550cb609f29c1943e78fc">labeling4</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type max_label, Functor f)</td></tr>
<tr class="memdesc:ga4525d91ad64550cb609f29c1943e78fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像に対する4近傍型ラベリング  <a href="group__labeling__group.html#ga4525d91ad64550cb609f29c1943e78fc"></a><br/></td></tr>
<tr class="memitem:gac6f0036a0f09a182cf881b1757a9fac4"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gac6f0036a0f09a182cf881b1757a9fac4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gac6f0036a0f09a182cf881b1757a9fac4">labeling4</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type max_label=__labeling_controller__::default_label_num2&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:gac6f0036a0f09a182cf881b1757a9fac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像に対する4近傍型ラベリング  <a href="group__labeling__group.html#gac6f0036a0f09a182cf881b1757a9fac4"></a><br/></td></tr>
<tr class="memitem:gacb7346f9b644c8a8314fb069b725c9a8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 , class Functor &gt; </td></tr>
<tr class="memitem:gacb7346f9b644c8a8314fb069b725c9a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gacb7346f9b644c8a8314fb069b725c9a8">labeling8</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type max_label, Functor f)</td></tr>
<tr class="memdesc:gacb7346f9b644c8a8314fb069b725c9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像に対する8近傍型ラベリング  <a href="group__labeling__group.html#gacb7346f9b644c8a8314fb069b725c9a8"></a><br/></td></tr>
<tr class="memitem:ga5a6bccfea833f8dc5984b835d644bbda"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga5a6bccfea833f8dc5984b835d644bbda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga5a6bccfea833f8dc5984b835d644bbda">labeling8</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt;::size_type max_label=__labeling_controller__::default_label_num2&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga5a6bccfea833f8dc5984b835d644bbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元画像に対する8近傍型ラベリング  <a href="group__labeling__group.html#ga5a6bccfea833f8dc5984b835d644bbda"></a><br/></td></tr>
<tr class="memitem:gaaa5cec904b596976a0851d5b5b1750df"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 , class Functor &gt; </td></tr>
<tr class="memitem:gaaa5cec904b596976a0851d5b5b1750df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gaaa5cec904b596976a0851d5b5b1750df">labeling6</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type max_label, Functor f)</td></tr>
<tr class="memdesc:gaaa5cec904b596976a0851d5b5b1750df"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に対する6近傍型ラベリング  <a href="group__labeling__group.html#gaaa5cec904b596976a0851d5b5b1750df"></a><br/></td></tr>
<tr class="memitem:ga9c6571e042cbacad5db2a4251c85832c"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga9c6571e042cbacad5db2a4251c85832c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga9c6571e042cbacad5db2a4251c85832c">labeling6</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type max_label=__labeling_controller__::default_label_num3&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga9c6571e042cbacad5db2a4251c85832c"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に対する6近傍型ラベリング  <a href="group__labeling__group.html#ga9c6571e042cbacad5db2a4251c85832c"></a><br/></td></tr>
<tr class="memitem:ga6f3ef28629aa0e5b2e0f2f2326166d37"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 , class Functor &gt; </td></tr>
<tr class="memitem:ga6f3ef28629aa0e5b2e0f2f2326166d37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga6f3ef28629aa0e5b2e0f2f2326166d37">labeling18</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type max_label, Functor f)</td></tr>
<tr class="memdesc:ga6f3ef28629aa0e5b2e0f2f2326166d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に対する18近傍型ラベリング  <a href="group__labeling__group.html#ga6f3ef28629aa0e5b2e0f2f2326166d37"></a><br/></td></tr>
<tr class="memitem:ga5b2a29c59708aea4c65d66b2e4d79f89"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga5b2a29c59708aea4c65d66b2e4d79f89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga5b2a29c59708aea4c65d66b2e4d79f89">labeling18</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type max_label=__labeling_controller__::default_label_num3&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga5b2a29c59708aea4c65d66b2e4d79f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に対する18近傍型ラベリング  <a href="group__labeling__group.html#ga5b2a29c59708aea4c65d66b2e4d79f89"></a><br/></td></tr>
<tr class="memitem:gab002f7a4bf7b6cb564a7bd8f92ff1dc5"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 , class Functor &gt; </td></tr>
<tr class="memitem:gab002f7a4bf7b6cb564a7bd8f92ff1dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gab002f7a4bf7b6cb564a7bd8f92ff1dc5">labeling26</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type max_label, Functor f)</td></tr>
<tr class="memdesc:gab002f7a4bf7b6cb564a7bd8f92ff1dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に対する26近傍型ラベリング  <a href="group__labeling__group.html#gab002f7a4bf7b6cb564a7bd8f92ff1dc5"></a><br/></td></tr>
<tr class="memitem:gae065a2486f8db43376350cb093d5c170"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gae065a2486f8db43376350cb093d5c170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gae065a2486f8db43376350cb093d5c170">labeling26</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt;::size_type max_label=__labeling_controller__::default_label_num3&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:gae065a2486f8db43376350cb093d5c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">3次元画像に対する26近傍型ラベリング  <a href="group__labeling__group.html#gae065a2486f8db43376350cb093d5c170"></a><br/></td></tr>
<tr class="memitem:gab4988aad0f149ad38fdc1fe6e728474b"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gab4988aad0f149ad38fdc1fe6e728474b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gab4988aad0f149ad38fdc1fe6e728474b">maximum_region</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type sx, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type ex, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type sy, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type ey, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num2&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:gab4988aad0f149ad38fdc1fe6e728474b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ある範囲内での最大のラベルを抽出する  <a href="group__labeling__group.html#gab4988aad0f149ad38fdc1fe6e728474b"></a><br/></td></tr>
<tr class="memitem:ga7415e934c78c71c7f4e496b421b09d8a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga7415e934c78c71c7f4e496b421b09d8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga7415e934c78c71c7f4e496b421b09d8a">maximum_region</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num2&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga7415e934c78c71c7f4e496b421b09d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像の全範囲内での最大のラベルを抽出する  <a href="group__labeling__group.html#ga7415e934c78c71c7f4e496b421b09d8a"></a><br/></td></tr>
<tr class="memitem:ga90faddb3959ebf22bad32463d1373ea1"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga90faddb3959ebf22bad32463d1373ea1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga90faddb3959ebf22bad32463d1373ea1">maximum_region</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type sx, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type ex, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type sy, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type ey, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type sz, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type ez, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num3&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga90faddb3959ebf22bad32463d1373ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ある範囲内での最大のラベルを抽出する  <a href="group__labeling__group.html#ga90faddb3959ebf22bad32463d1373ea1"></a><br/></td></tr>
<tr class="memitem:ga9c90d9468af507b6218f3de3facbde79"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga9c90d9468af507b6218f3de3facbde79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga9c90d9468af507b6218f3de3facbde79">maximum_region</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num3&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga9c90d9468af507b6218f3de3facbde79"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像の全範囲内での最大のラベルを抽出する  <a href="group__labeling__group.html#ga9c90d9468af507b6218f3de3facbde79"></a><br/></td></tr>
<tr class="memitem:gab1b35af94b40a90520ec3c12adfac3e8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gab1b35af94b40a90520ec3c12adfac3e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gab1b35af94b40a90520ec3c12adfac3e8">remove_hole_region</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, const bool include_corner_labels, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num2&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:gab1b35af94b40a90520ec3c12adfac3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像の0/1を反転させて穴埋め処理を行う  <a href="group__labeling__group.html#gab1b35af94b40a90520ec3c12adfac3e8"></a><br/></td></tr>
<tr class="memitem:ga93a8c4cef38b2b08823f13826b79e94d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga93a8c4cef38b2b08823f13826b79e94d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga93a8c4cef38b2b08823f13826b79e94d">remove_hole_region</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num2&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga93a8c4cef38b2b08823f13826b79e94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像の0/1を反転させて穴埋め処理を行う  <a href="group__labeling__group.html#ga93a8c4cef38b2b08823f13826b79e94d"></a><br/></td></tr>
<tr class="memitem:ga9a83ed9672830f242612fb016313421f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga9a83ed9672830f242612fb016313421f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#ga9a83ed9672830f242612fb016313421f">remove_hole_region</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, const bool include_corner_labels, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num3&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:ga9a83ed9672830f242612fb016313421f"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像の0/1を反転させて穴埋め処理を行う  <a href="group__labeling__group.html#ga9a83ed9672830f242612fb016313421f"></a><br/></td></tr>
<tr class="memitem:gaa56f7a6c056f7b49f0594d0273e07588"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gaa56f7a6c056f7b49f0594d0273e07588"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__labeling__group.html#gaa56f7a6c056f7b49f0594d0273e07588">remove_hole_region</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type max_label=__labeling_controller__::default_label_num3&lt; T2 &gt;::value)</td></tr>
<tr class="memdesc:gaa56f7a6c056f7b49f0594d0273e07588"><td class="mdescLeft">&#160;</td><td class="mdescRight">画像の0/1を反転させて穴埋め処理を行う  <a href="group__labeling__group.html#gaa56f7a6c056f7b49f0594d0273e07588"></a><br/></td></tr>
<tr class="memitem:gab7462396eef1092ec686c96ac9936868"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class Kernel &gt; </td></tr>
<tr class="memitem:gab7462396eef1092ec686c96ac9936868"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linear__group.html#gab7462396eef1092ec686c96ac9936868">linear_filter</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array.html">array</a>&lt; T2, Allocator2 &gt; &amp;out, const Kernel &amp;kernel, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gab7462396eef1092ec686c96ac9936868"><td class="mdescLeft">&#160;</td><td class="mdescRight">一般の線形フィルタ( array )  <a href="group__linear__group.html#gab7462396eef1092ec686c96ac9936868"></a><br/></td></tr>
<tr class="memitem:gad276974afe38d6b9547559d2f2664f40"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class Kernel &gt; </td></tr>
<tr class="memitem:gad276974afe38d6b9547559d2f2664f40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linear__group.html#gad276974afe38d6b9547559d2f2664f40">linear_filter</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out, const Kernel &amp;kernel, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gad276974afe38d6b9547559d2f2664f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">一般の線形フィルタ( array1 )  <a href="group__linear__group.html#gad276974afe38d6b9547559d2f2664f40"></a><br/></td></tr>
<tr class="memitem:ga44a75d55705d6adcf8d6f30d4615c409"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class Kernel &gt; </td></tr>
<tr class="memitem:ga44a75d55705d6adcf8d6f30d4615c409"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linear__group.html#ga44a75d55705d6adcf8d6f30d4615c409">linear_filter</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, const Kernel &amp;kernel, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga44a75d55705d6adcf8d6f30d4615c409"><td class="mdescLeft">&#160;</td><td class="mdescRight">一般の線形フィルタ( array2 )  <a href="group__linear__group.html#ga44a75d55705d6adcf8d6f30d4615c409"></a><br/></td></tr>
<tr class="memitem:gad8b0a484696ca70cada06645329b4c88"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class Kernel &gt; </td></tr>
<tr class="memitem:gad8b0a484696ca70cada06645329b4c88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linear__group.html#gad8b0a484696ca70cada06645329b4c88">linear_filter</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, const Kernel &amp;kernel, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gad8b0a484696ca70cada06645329b4c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">一般の線形フィルタ( array3 )  <a href="group__linear__group.html#gad8b0a484696ca70cada06645329b4c88"></a><br/></td></tr>
<tr class="memitem:ga489ac607f4d3a57f958e05f1d05fb54e"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga489ac607f4d3a57f958e05f1d05fb54e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__laplacian__group.html#ga489ac607f4d3a57f958e05f1d05fb54e">laplacian_filter</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array.html">array</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga489ac607f4d3a57f958e05f1d05fb54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ラプラシアン( array )  <a href="group__laplacian__group.html#ga489ac607f4d3a57f958e05f1d05fb54e"></a><br/></td></tr>
<tr class="memitem:gabf2ad75aff1df72d0691be926069c709"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gabf2ad75aff1df72d0691be926069c709"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__laplacian__group.html#gabf2ad75aff1df72d0691be926069c709">laplacian_filter</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gabf2ad75aff1df72d0691be926069c709"><td class="mdescLeft">&#160;</td><td class="mdescRight">ラプラシアン( array1 )  <a href="group__laplacian__group.html#gabf2ad75aff1df72d0691be926069c709"></a><br/></td></tr>
<tr class="memitem:ga229acc0c4370604910c1883942287cf8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga229acc0c4370604910c1883942287cf8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__laplacian__group.html#ga229acc0c4370604910c1883942287cf8">laplacian_filter</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga229acc0c4370604910c1883942287cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ラプラシアン( array2 )  <a href="group__laplacian__group.html#ga229acc0c4370604910c1883942287cf8"></a><br/></td></tr>
<tr class="memitem:ga9ed68ccd93f6efce7ea12644085fd462"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga9ed68ccd93f6efce7ea12644085fd462"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__laplacian__group.html#ga9ed68ccd93f6efce7ea12644085fd462">laplacian_filter</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga9ed68ccd93f6efce7ea12644085fd462"><td class="mdescLeft">&#160;</td><td class="mdescRight">ラプラシアン( array3 )  <a href="group__laplacian__group.html#ga9ed68ccd93f6efce7ea12644085fd462"></a><br/></td></tr>
<tr class="memitem:ga89701e76eee4e634cc8635d01d6aa894"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga89701e76eee4e634cc8635d01d6aa894"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gaussian__group.html#ga89701e76eee4e634cc8635d01d6aa894">gaussian_filter</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array.html">array</a>&lt; T2, Allocator2 &gt; &amp;out, const double sigma=1.0, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga89701e76eee4e634cc8635d01d6aa894"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガウシアンフィルタ( array )  <a href="group__gaussian__group.html#ga89701e76eee4e634cc8635d01d6aa894"></a><br/></td></tr>
<tr class="memitem:ga6cc050e5ea0cd6045491a0a695d141f9"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga6cc050e5ea0cd6045491a0a695d141f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gaussian__group.html#ga6cc050e5ea0cd6045491a0a695d141f9">gaussian_filter</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out, const double sigma=1.0, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga6cc050e5ea0cd6045491a0a695d141f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガウシアンフィルタ( array1 )  <a href="group__gaussian__group.html#ga6cc050e5ea0cd6045491a0a695d141f9"></a><br/></td></tr>
<tr class="memitem:gac2dc10654ab6ef4ca9861a9b8262030d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gac2dc10654ab6ef4ca9861a9b8262030d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gaussian__group.html#gac2dc10654ab6ef4ca9861a9b8262030d">gaussian_filter</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, const double sigma=1.0, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gac2dc10654ab6ef4ca9861a9b8262030d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガウシアンフィルタ( array2 )  <a href="group__gaussian__group.html#gac2dc10654ab6ef4ca9861a9b8262030d"></a><br/></td></tr>
<tr class="memitem:ga580091a6924520683106ff5a3ec69998"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga580091a6924520683106ff5a3ec69998"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gaussian__group.html#ga580091a6924520683106ff5a3ec69998">gaussian_filter</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, const double sigma=1.0, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga580091a6924520683106ff5a3ec69998"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガウシアンフィルタ( array2 )  <a href="group__gaussian__group.html#ga580091a6924520683106ff5a3ec69998"></a><br/></td></tr>
<tr class="memitem:ga69dd26eef2f015863533627c989c3ea6"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga69dd26eef2f015863533627c989c3ea6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gaussian__group.html#ga69dd26eef2f015863533627c989c3ea6">gaussian_filter</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, const double sigma=1.0, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga69dd26eef2f015863533627c989c3ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガウシアンフィルタ( array3 )  <a href="group__gaussian__group.html#ga69dd26eef2f015863533627c989c3ea6"></a><br/></td></tr>
<tr class="memitem:ga3585f24ef2bc40880b3bb5bfcf9eb235"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga3585f24ef2bc40880b3bb5bfcf9eb235"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gaussian__group.html#ga3585f24ef2bc40880b3bb5bfcf9eb235">gaussian_filter</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, const double sigma=1.0, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga3585f24ef2bc40880b3bb5bfcf9eb235"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガウシアンフィルタ( array3 )  <a href="group__gaussian__group.html#ga3585f24ef2bc40880b3bb5bfcf9eb235"></a><br/></td></tr>
<tr class="memitem:ga1798c622c35569098a8925b953b1ba23"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga1798c622c35569098a8925b953b1ba23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__average__group.html#ga1798c622c35569098a8925b953b1ba23">average_filter</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array.html">array</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga1798c622c35569098a8925b953b1ba23"><td class="mdescLeft">&#160;</td><td class="mdescRight">一様重み( array )  <a href="group__average__group.html#ga1798c622c35569098a8925b953b1ba23"></a><br/></td></tr>
<tr class="memitem:gadef33aec9dab09ecce36d61eac36dde9"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gadef33aec9dab09ecce36d61eac36dde9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__average__group.html#gadef33aec9dab09ecce36d61eac36dde9">average_filter</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gadef33aec9dab09ecce36d61eac36dde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">一様重み( array1 )  <a href="group__average__group.html#gadef33aec9dab09ecce36d61eac36dde9"></a><br/></td></tr>
<tr class="memitem:ga4d7e4516a9417adf2c65cd5a757642ea"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga4d7e4516a9417adf2c65cd5a757642ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__average__group.html#ga4d7e4516a9417adf2c65cd5a757642ea">average_filter</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type fh, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga4d7e4516a9417adf2c65cd5a757642ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">一様重み( array2 )  <a href="group__average__group.html#ga4d7e4516a9417adf2c65cd5a757642ea"></a><br/></td></tr>
<tr class="memitem:ga83b45700c9ee186bd265a2c0a8396aa2"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga83b45700c9ee186bd265a2c0a8396aa2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__average__group.html#ga83b45700c9ee186bd265a2c0a8396aa2">average_filter</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fh, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fd, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga83b45700c9ee186bd265a2c0a8396aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">一様重み( array3 )  <a href="group__average__group.html#ga83b45700c9ee186bd265a2c0a8396aa2"></a><br/></td></tr>
<tr class="memitem:ga5941dca528cb1a97a876e50507785833"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga5941dca528cb1a97a876e50507785833"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#ga5941dca528cb1a97a876e50507785833">median</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array.html">array</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga5941dca528cb1a97a876e50507785833"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#ga5941dca528cb1a97a876e50507785833"></a><br/></td></tr>
<tr class="memitem:gad2f20973ab301ab0d3cea5aa9d12ebb2"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gad2f20973ab301ab0d3cea5aa9d12ebb2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#gad2f20973ab301ab0d3cea5aa9d12ebb2">median</a> (const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gad2f20973ab301ab0d3cea5aa9d12ebb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#gad2f20973ab301ab0d3cea5aa9d12ebb2"></a><br/></td></tr>
<tr class="memitem:gaf752af3c8108ec0769fc5821a21f79ed"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class Functor &gt; </td></tr>
<tr class="memitem:gaf752af3c8108ec0769fc5821a21f79ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#gaf752af3c8108ec0769fc5821a21f79ed">median</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type fh, Functor f, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:gaf752af3c8108ec0769fc5821a21f79ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#gaf752af3c8108ec0769fc5821a21f79ed"></a><br/></td></tr>
<tr class="memitem:gabf0d0160f4069725e9faff420973a7aa"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gabf0d0160f4069725e9faff420973a7aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#gabf0d0160f4069725e9faff420973a7aa">median</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type fh, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:gabf0d0160f4069725e9faff420973a7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#gabf0d0160f4069725e9faff420973a7aa"></a><br/></td></tr>
<tr class="memitem:ga31348ef387b4c3dc7d26107b556fed71"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga31348ef387b4c3dc7d26107b556fed71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#ga31348ef387b4c3dc7d26107b556fed71">median</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga31348ef387b4c3dc7d26107b556fed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#ga31348ef387b4c3dc7d26107b556fed71"></a><br/></td></tr>
<tr class="memitem:ga7e3d1068858c685c72ba74293dae2f10"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class Functor &gt; </td></tr>
<tr class="memitem:ga7e3d1068858c685c72ba74293dae2f10"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#ga7e3d1068858c685c72ba74293dae2f10">median</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fh, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fd, Functor f, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:ga7e3d1068858c685c72ba74293dae2f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#ga7e3d1068858c685c72ba74293dae2f10"></a><br/></td></tr>
<tr class="memitem:ga0e89d3ba6e727a77fab47759055a895c"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga0e89d3ba6e727a77fab47759055a895c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#ga0e89d3ba6e727a77fab47759055a895c">median</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fh, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fd, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:ga0e89d3ba6e727a77fab47759055a895c"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#ga0e89d3ba6e727a77fab47759055a895c"></a><br/></td></tr>
<tr class="memitem:ga3a4405aed135bbe49d1e32ed569cc57d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga3a4405aed135bbe49d1e32ed569cc57d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__median__group.html#ga3a4405aed135bbe49d1e32ed569cc57d">median</a> (const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt; &amp;in, <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T2, Allocator2 &gt; &amp;out, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type fw, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T1, Allocator1 &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga3a4405aed135bbe49d1e32ed569cc57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">メディアン（中央値）フィルタを適用する  <a href="group__median__group.html#ga3a4405aed135bbe49d1e32ed569cc57d"></a><br/></td></tr>
<tr class="memitem:ga8820313fa0f62e950e18a22083c2bc68"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga8820313fa0f62e950e18a22083c2bc68"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#ga8820313fa0f62e950e18a22083c2bc68">mode</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, const <a class="el" href="structmist_1_1mode__filter_1_1mode__structure.html">mode_filter::mode_structure</a> &amp;s, Functor f, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:ga8820313fa0f62e950e18a22083c2bc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応した最頻値フィルタ  <a href="group__mode__group.html#ga8820313fa0f62e950e18a22083c2bc68"></a><br/></td></tr>
<tr class="memitem:ga8b5f5deca57ec112f8064278a297b237"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga8b5f5deca57ec112f8064278a297b237"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#ga8b5f5deca57ec112f8064278a297b237">mode</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, const <a class="el" href="structmist_1_1mode__filter_1_1mode__structure.html">mode_filter::mode_structure</a> &amp;s, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga8b5f5deca57ec112f8064278a297b237"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応した最頻値フィルタ  <a href="group__mode__group.html#ga8b5f5deca57ec112f8064278a297b237"></a><br/></td></tr>
<tr class="memitem:gaf1cc81fcb38ffad645a8f8de4a8acb33"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:gaf1cc81fcb38ffad645a8f8de4a8acb33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#gaf1cc81fcb38ffad645a8f8de4a8acb33">mode</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, double radius, Functor f, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:gaf1cc81fcb38ffad645a8f8de4a8acb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">円を構造要素とする最頻値フィルタ  <a href="group__mode__group.html#gaf1cc81fcb38ffad645a8f8de4a8acb33"></a><br/></td></tr>
<tr class="memitem:ga30145212da9d0115e8180747e69b7601"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga30145212da9d0115e8180747e69b7601"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#ga30145212da9d0115e8180747e69b7601">mode</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;in, double radius, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga30145212da9d0115e8180747e69b7601"><td class="mdescLeft">&#160;</td><td class="mdescRight">円を構造要素とする最頻値フィルタ  <a href="group__mode__group.html#ga30145212da9d0115e8180747e69b7601"></a><br/></td></tr>
<tr class="memitem:gaf8f18c3973185b1324963d2e67ba4606"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:gaf8f18c3973185b1324963d2e67ba4606"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#gaf8f18c3973185b1324963d2e67ba4606">mode</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, const <a class="el" href="structmist_1_1mode__filter_1_1mode__structure.html">mode_filter::mode_structure</a> &amp;s, Functor f, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:gaf8f18c3973185b1324963d2e67ba4606"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応した最頻値フィルタ  <a href="group__mode__group.html#gaf8f18c3973185b1324963d2e67ba4606"></a><br/></td></tr>
<tr class="memitem:ga5dddfc60e79d47eba7949284cf10d6f4"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga5dddfc60e79d47eba7949284cf10d6f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#ga5dddfc60e79d47eba7949284cf10d6f4">mode</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, const <a class="el" href="structmist_1_1mode__filter_1_1mode__structure.html">mode_filter::mode_structure</a> &amp;s, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga5dddfc60e79d47eba7949284cf10d6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応した最頻値フィルタ  <a href="group__mode__group.html#ga5dddfc60e79d47eba7949284cf10d6f4"></a><br/></td></tr>
<tr class="memitem:gaa6a41c925eab670343e6a43fb56a4b5b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:gaa6a41c925eab670343e6a43fb56a4b5b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#gaa6a41c925eab670343e6a43fb56a4b5b">mode</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, double radius, Functor f, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type thread_num)</td></tr>
<tr class="memdesc:gaa6a41c925eab670343e6a43fb56a4b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とする最頻値フィルタ  <a href="group__mode__group.html#gaa6a41c925eab670343e6a43fb56a4b5b"></a><br/></td></tr>
<tr class="memitem:gae243779217caf8bd40fc8de22b68c409"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gae243779217caf8bd40fc8de22b68c409"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mode__group.html#gae243779217caf8bd40fc8de22b68c409">mode</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;in, double radius, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type thread_num=0)</td></tr>
<tr class="memdesc:gae243779217caf8bd40fc8de22b68c409"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とする最頻値フィルタ  <a href="group__mode__group.html#gae243779217caf8bd40fc8de22b68c409"></a><br/></td></tr>
<tr class="memitem:ga4cfd75b7c98fa05078f0bc292d2d2b8f"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:ga4cfd75b7c98fa05078f0bc292d2d2b8f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga4cfd75b7c98fa05078f0bc292d2d2b8f">erosion</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:ga4cfd75b7c98fa05078f0bc292d2d2b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したErosion演算  <a href="group__morphology__group.html#ga4cfd75b7c98fa05078f0bc292d2d2b8f"></a><br/></td></tr>
<tr class="memitem:ga79fcd98dca5b829a9afe0ecaa3384071"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga79fcd98dca5b829a9afe0ecaa3384071"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga79fcd98dca5b829a9afe0ecaa3384071">erosion</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga79fcd98dca5b829a9afe0ecaa3384071"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したErosion演算  <a href="group__morphology__group.html#ga79fcd98dca5b829a9afe0ecaa3384071"></a><br/></td></tr>
<tr class="memitem:gac856095b56c1a72f28f935246b52a265"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:gac856095b56c1a72f28f935246b52a265"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#gac856095b56c1a72f28f935246b52a265">dilation</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:gac856095b56c1a72f28f935246b52a265"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したDilation演算  <a href="group__morphology__group.html#gac856095b56c1a72f28f935246b52a265"></a><br/></td></tr>
<tr class="memitem:ga2270d1de7ab82e0908256a63f0c255ce"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga2270d1de7ab82e0908256a63f0c255ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga2270d1de7ab82e0908256a63f0c255ce">dilation</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga2270d1de7ab82e0908256a63f0c255ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したDilation演算  <a href="group__morphology__group.html#ga2270d1de7ab82e0908256a63f0c255ce"></a><br/></td></tr>
<tr class="memitem:ga99d5819b28dfe92e222fa0147c1cf9f8"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:ga99d5819b28dfe92e222fa0147c1cf9f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga99d5819b28dfe92e222fa0147c1cf9f8">opening</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:ga99d5819b28dfe92e222fa0147c1cf9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したOpening演算  <a href="group__morphology__group.html#ga99d5819b28dfe92e222fa0147c1cf9f8"></a><br/></td></tr>
<tr class="memitem:ga1b8f2156331461b77d5ff3b1f823b8ff"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga1b8f2156331461b77d5ff3b1f823b8ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga1b8f2156331461b77d5ff3b1f823b8ff">opening</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga1b8f2156331461b77d5ff3b1f823b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したOpening演算  <a href="group__morphology__group.html#ga1b8f2156331461b77d5ff3b1f823b8ff"></a><br/></td></tr>
<tr class="memitem:ga573121226332924e8d3a9a6aa80c7f07"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:ga573121226332924e8d3a9a6aa80c7f07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga573121226332924e8d3a9a6aa80c7f07">closing</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:ga573121226332924e8d3a9a6aa80c7f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したClosing演算  <a href="group__morphology__group.html#ga573121226332924e8d3a9a6aa80c7f07"></a><br/></td></tr>
<tr class="memitem:ga4ef4d3057c18f893cf861b2dcf09f08e"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga4ef4d3057c18f893cf861b2dcf09f08e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga4ef4d3057c18f893cf861b2dcf09f08e">closing</a> (Array &amp;in, const <a class="el" href="structmist_1_1morphology_1_1morphology__structure.html">morphology::morphology_structure</a> &amp;s, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga4ef4d3057c18f893cf861b2dcf09f08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素に対応したClosing演算  <a href="group__morphology__group.html#ga4ef4d3057c18f893cf861b2dcf09f08e"></a><br/></td></tr>
<tr class="memitem:gaf1fef5380ee5762ca7c5ee3c4f9f6bf1"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:gaf1fef5380ee5762ca7c5ee3c4f9f6bf1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#gaf1fef5380ee5762ca7c5ee3c4f9f6bf1">erosion</a> (Array &amp;in, double radius, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:gaf1fef5380ee5762ca7c5ee3c4f9f6bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするErosion演算  <a href="group__morphology__group.html#gaf1fef5380ee5762ca7c5ee3c4f9f6bf1"></a><br/></td></tr>
<tr class="memitem:gac7341085467a84c17a6d6fe2d3bf6555"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:gac7341085467a84c17a6d6fe2d3bf6555"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#gac7341085467a84c17a6d6fe2d3bf6555">dilation</a> (Array &amp;in, double radius, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:gac7341085467a84c17a6d6fe2d3bf6555"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするDilation演算  <a href="group__morphology__group.html#gac7341085467a84c17a6d6fe2d3bf6555"></a><br/></td></tr>
<tr class="memitem:gaf748e3254adf903183f2bd80dba659ee"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:gaf748e3254adf903183f2bd80dba659ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#gaf748e3254adf903183f2bd80dba659ee">opening</a> (Array &amp;in, double radius, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:gaf748e3254adf903183f2bd80dba659ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするOpening演算  <a href="group__morphology__group.html#gaf748e3254adf903183f2bd80dba659ee"></a><br/></td></tr>
<tr class="memitem:ga511f1202c0d8c2c96eb0dc10af2a3e97"><td class="memTemplParams" colspan="2">template&lt;class Array , class Functor &gt; </td></tr>
<tr class="memitem:ga511f1202c0d8c2c96eb0dc10af2a3e97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga511f1202c0d8c2c96eb0dc10af2a3e97">closing</a> (Array &amp;in, double radius, Functor f, typename Array::size_type thread_num)</td></tr>
<tr class="memdesc:ga511f1202c0d8c2c96eb0dc10af2a3e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするClosing演算  <a href="group__morphology__group.html#ga511f1202c0d8c2c96eb0dc10af2a3e97"></a><br/></td></tr>
<tr class="memitem:ga7573e874a96fecf8e0d98199917291f9"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga7573e874a96fecf8e0d98199917291f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga7573e874a96fecf8e0d98199917291f9">erosion</a> (Array &amp;in, double radius, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga7573e874a96fecf8e0d98199917291f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするErosion演算  <a href="group__morphology__group.html#ga7573e874a96fecf8e0d98199917291f9"></a><br/></td></tr>
<tr class="memitem:ga26d6629d1a21601fd0819c76d82bb2d1"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga26d6629d1a21601fd0819c76d82bb2d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#ga26d6629d1a21601fd0819c76d82bb2d1">dilation</a> (Array &amp;in, double radius, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga26d6629d1a21601fd0819c76d82bb2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするDilation演算  <a href="group__morphology__group.html#ga26d6629d1a21601fd0819c76d82bb2d1"></a><br/></td></tr>
<tr class="memitem:gaad85d383ecd1957220e5aaed3d9eed9a"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:gaad85d383ecd1957220e5aaed3d9eed9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#gaad85d383ecd1957220e5aaed3d9eed9a">opening</a> (Array &amp;in, double radius, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:gaad85d383ecd1957220e5aaed3d9eed9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするOpening演算  <a href="group__morphology__group.html#gaad85d383ecd1957220e5aaed3d9eed9a"></a><br/></td></tr>
<tr class="memitem:gaa440cdd7deaeba3543c7a96affd16ccc"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:gaa440cdd7deaeba3543c7a96affd16ccc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__morphology__group.html#gaa440cdd7deaeba3543c7a96affd16ccc">closing</a> (Array &amp;in, double radius, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:gaa440cdd7deaeba3543c7a96affd16ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">球を構造要素とするClosing演算  <a href="group__morphology__group.html#gaa440cdd7deaeba3543c7a96affd16ccc"></a><br/></td></tr>
<tr class="memitem:gabae77324d51d95c848be61462fd817e5"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class MaskType , class PointList , class Component , class Condition &gt; </td></tr>
<tr class="memitem:gabae77324d51d95c848be61462fd817e5"><td class="memTemplItemLeft" align="right" valign="top">Array1::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__region__growing__group.html#gabae77324d51d95c848be61462fd817e5">region_growing</a> (const Array1 &amp;in, Array2 &amp;out, const MaskType &amp;mask, const PointList &amp;start_points, typename Array2::value_type output_value, const Component &amp;components, const Condition &amp;condition, typename Array1::size_type max_paint)</td></tr>
<tr class="memdesc:gabae77324d51d95c848be61462fd817e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素と条件を用いて領域拡張を行う関数  <a href="group__region__growing__group.html#gabae77324d51d95c848be61462fd817e5"></a><br/></td></tr>
<tr class="memitem:gaec4ddb74f83f51b4accaa11df033dd21"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class PointList , class Component , class Condition &gt; </td></tr>
<tr class="memitem:gaec4ddb74f83f51b4accaa11df033dd21"><td class="memTemplItemLeft" align="right" valign="top">Array1::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__region__growing__group.html#gaec4ddb74f83f51b4accaa11df033dd21">region_growing</a> (const Array1 &amp;in, Array2 &amp;out, const PointList &amp;start_points, typename Array2::value_type output_value, const Component &amp;components, const Condition &amp;condition, typename Array1::size_type max_paint=<a class="el" href="structmist_1_1type__limits.html">type_limits</a>&lt; typename Array1::size_type &gt;::maximum())</td></tr>
<tr class="memdesc:gaec4ddb74f83f51b4accaa11df033dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">任意の構造要素と条件を用いて領域拡張を行う関数  <a href="group__region__growing__group.html#gaec4ddb74f83f51b4accaa11df033dd21"></a><br/></td></tr>
<tr class="memitem:adca49273c7ff92351816821784f7ca6d"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:adca49273c7ff92351816821784f7ca6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#adca49273c7ff92351816821784f7ca6d">translation_matrix</a> (<a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;mat, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type x, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type y)</td></tr>
<tr class="memdesc:adca49273c7ff92351816821784f7ca6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate translation matrix  <a href="#adca49273c7ff92351816821784f7ca6d"></a><br/></td></tr>
<tr class="memitem:a64ba8af07977af38891e18fc2558dc18"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a64ba8af07977af38891e18fc2558dc18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a64ba8af07977af38891e18fc2558dc18">rotation_matrix</a> (<a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;mat, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type radian)</td></tr>
<tr class="memdesc:a64ba8af07977af38891e18fc2558dc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate rotation matrix  <a href="#a64ba8af07977af38891e18fc2558dc18"></a><br/></td></tr>
<tr class="memitem:a8a4bb6fee2b1641a2951fcb5a40b944a"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a8a4bb6fee2b1641a2951fcb5a40b944a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a8a4bb6fee2b1641a2951fcb5a40b944a">rotation_matrix</a> (<a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;mat, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type radian, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type cx, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type cy)</td></tr>
<tr class="memdesc:a8a4bb6fee2b1641a2951fcb5a40b944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate rotation matrix  <a href="#a8a4bb6fee2b1641a2951fcb5a40b944a"></a><br/></td></tr>
<tr class="memitem:afede2b385e98e06e5571bd1b7f055fee"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:afede2b385e98e06e5571bd1b7f055fee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#afede2b385e98e06e5571bd1b7f055fee">scaling_matrix</a> (<a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;mat, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type x, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type y)</td></tr>
<tr class="memdesc:afede2b385e98e06e5571bd1b7f055fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate scaling matrix  <a href="#afede2b385e98e06e5571bd1b7f055fee"></a><br/></td></tr>
<tr class="memitem:ac621dd7adbc4d81ad1d16e2d64968f23"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ac621dd7adbc4d81ad1d16e2d64968f23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ac621dd7adbc4d81ad1d16e2d64968f23">homography_matrix</a> (<a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;mat, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;p1, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;p2)</td></tr>
<tr class="memdesc:ac621dd7adbc4d81ad1d16e2d64968f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate homography matrix  <a href="#ac621dd7adbc4d81ad1d16e2d64968f23"></a><br/></td></tr>
<tr class="memitem:gad13a8889e6d64783b6288ea26efeeeb5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__group.html#gad13a8889e6d64783b6288ea26efeeeb5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1hash__algorithm.html">hash_algorithm</a> &amp;h)</td></tr>
<tr class="memdesc:gad13a8889e6d64783b6288ea26efeeeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームにデータを出力する  <a href="group__hash__group.html#gad13a8889e6d64783b6288ea26efeeeb5"></a><br/></td></tr>
<tr class="memitem:ga9bc60d0a6dcb540645a24a1b40212f4b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9bc60d0a6dcb540645a24a1b40212f4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hht__group.html#ga9bc60d0a6dcb540645a24a1b40212f4b">hilbert</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T &gt; &amp;in, <a class="el" href="classmist_1_1array.html">array</a>&lt; std::complex&lt; T &gt; &gt; &amp;out, bool mirror=false)</td></tr>
<tr class="memdesc:ga9bc60d0a6dcb540645a24a1b40212f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒルベルト変換  <a href="group__hht__group.html#ga9bc60d0a6dcb540645a24a1b40212f4b"></a><br/></td></tr>
<tr class="memitem:ga754b6e040d3c06ae2be785c24b1d9f09"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga754b6e040d3c06ae2be785c24b1d9f09"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hht__group.html#ga754b6e040d3c06ae2be785c24b1d9f09">emd</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T1 &gt; &amp;in, <a class="el" href="classmist_1_1array.html">array</a>&lt; T2 &gt; &amp;imf, double sd=0.3)</td></tr>
<tr class="memdesc:ga754b6e040d3c06ae2be785c24b1d9f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">経験的モード分解  <a href="group__hht__group.html#ga754b6e040d3c06ae2be785c24b1d9f09"></a><br/></td></tr>
<tr class="memitem:gaeab42f70d7c43acc83a82aac161a2488"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaeab42f70d7c43acc83a82aac161a2488"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__image__group.html#gaeab42f70d7c43acc83a82aac161a2488">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1integral__image.html">integral_image</a>&lt; <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:gaeab42f70d7c43acc83a82aac161a2488"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__integral__image__group.html#gaeab42f70d7c43acc83a82aac161a2488"></a><br/></td></tr>
<tr class="memitem:ga370a8bbe60dbfb864e4fefc2b097803a"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga370a8bbe60dbfb864e4fefc2b097803a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__image__group.html#ga370a8bbe60dbfb864e4fefc2b097803a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1integral__image.html">integral_image</a>&lt; <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:ga370a8bbe60dbfb864e4fefc2b097803a"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__integral__image__group.html#ga370a8bbe60dbfb864e4fefc2b097803a"></a><br/></td></tr>
<tr class="memitem:gaac1067803553fdfb840d3c73790801ea"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaac1067803553fdfb840d3c73790801ea"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__image__group.html#gaac1067803553fdfb840d3c73790801ea">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1integral__image.html">integral_image</a>&lt; <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:gaac1067803553fdfb840d3c73790801ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__integral__image__group.html#gaac1067803553fdfb840d3c73790801ea"></a><br/></td></tr>
<tr class="memitem:gac3ea531d22a18c76da7fd2e6d2e724df"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gac3ea531d22a18c76da7fd2e6d2e724df"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__image__group.html#gac3ea531d22a18c76da7fd2e6d2e724df">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1integral__image.html">integral_image</a>&lt; <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:gac3ea531d22a18c76da7fd2e6d2e724df"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="group__integral__image__group.html#gac3ea531d22a18c76da7fd2e6d2e724df"></a><br/></td></tr>
<tr class="memitem:ga3148e2d706b35385b98790966f6ff022"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga3148e2d706b35385b98790966f6ff022"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__bmp__group.html#ga3148e2d706b35385b98790966f6ff022">read_bmp</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga3148e2d706b35385b98790966f6ff022"><td class="mdescLeft">&#160;</td><td class="mdescRight">BMP画像をMISTコンテナに読み込む  <a href="group__image__bmp__group.html#ga3148e2d706b35385b98790966f6ff022"></a><br/></td></tr>
<tr class="memitem:gace5138da5cc309ff328fe910427b7e41"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gace5138da5cc309ff328fe910427b7e41"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__bmp__group.html#gace5138da5cc309ff328fe910427b7e41">read_bmp</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gace5138da5cc309ff328fe910427b7e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">BMP画像をMISTコンテナに読み込む  <a href="group__image__bmp__group.html#gace5138da5cc309ff328fe910427b7e41"></a><br/></td></tr>
<tr class="memitem:gaed6d24f0d1a35077c277e16df1775ea6"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaed6d24f0d1a35077c277e16df1775ea6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__bmp__group.html#gaed6d24f0d1a35077c277e16df1775ea6">write_bmp</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type bmp_bits=24)</td></tr>
<tr class="memdesc:gaed6d24f0d1a35077c277e16df1775ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をBMP形式でファイルに出力する  <a href="group__image__bmp__group.html#gaed6d24f0d1a35077c277e16df1775ea6"></a><br/></td></tr>
<tr class="memitem:gabe15517635af4f3fd6a6d5e3ba8f7dd4"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gabe15517635af4f3fd6a6d5e3ba8f7dd4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__bmp__group.html#gabe15517635af4f3fd6a6d5e3ba8f7dd4">write_bmp</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type bmp_bits=24)</td></tr>
<tr class="memdesc:gabe15517635af4f3fd6a6d5e3ba8f7dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をBMP形式でファイルに出力する  <a href="group__image__bmp__group.html#gabe15517635af4f3fd6a6d5e3ba8f7dd4"></a><br/></td></tr>
<tr class="memitem:ga9597ed0246bc731d10fbaad029dba4e1"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga9597ed0246bc731d10fbaad029dba4e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csv__data__group.html#ga9597ed0246bc731d10fbaad029dba4e1">read_csv</a> (Array &amp;csv, const std::string &amp;filename, const std::string &amp;separator=&quot;, &quot;)</td></tr>
<tr class="memdesc:ga9597ed0246bc731d10fbaad029dba4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSV形式のファイルをSTLコンテナに読み込む  <a href="group__csv__data__group.html#ga9597ed0246bc731d10fbaad029dba4e1"></a><br/></td></tr>
<tr class="memitem:ga44ea8d02b256a85839078c63511dc5c7"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga44ea8d02b256a85839078c63511dc5c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csv__data__group.html#ga44ea8d02b256a85839078c63511dc5c7">read_csv</a> (Array &amp;csv, const std::wstring &amp;filename, const std::wstring &amp;separator=&quot;, &quot;)</td></tr>
<tr class="memdesc:ga44ea8d02b256a85839078c63511dc5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSV形式のファイルをSTLコンテナに読み込む  <a href="group__csv__data__group.html#ga44ea8d02b256a85839078c63511dc5c7"></a><br/></td></tr>
<tr class="memitem:ga3fe2f6ed46bae0682605a14629909932"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga3fe2f6ed46bae0682605a14629909932"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csv__data__group.html#ga3fe2f6ed46bae0682605a14629909932">read_csv</a> (<a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;csv, const std::string &amp;filename, const std::string &amp;separator=&quot;, &quot;)</td></tr>
<tr class="memdesc:ga3fe2f6ed46bae0682605a14629909932"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSV形式のファイルをMISTコンテナ（mist::matrix）に読み込む  <a href="group__csv__data__group.html#ga3fe2f6ed46bae0682605a14629909932"></a><br/></td></tr>
<tr class="memitem:ga2af779be83eec6373ec6ea47492b823d"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga2af779be83eec6373ec6ea47492b823d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csv__data__group.html#ga2af779be83eec6373ec6ea47492b823d">read_csv</a> (<a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;csv, const std::wstring &amp;filename, const std::string &amp;separator=&quot;, &quot;)</td></tr>
<tr class="memdesc:ga2af779be83eec6373ec6ea47492b823d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSV形式のファイルをMISTコンテナ（mist::matrix）に読み込む  <a href="group__csv__data__group.html#ga2af779be83eec6373ec6ea47492b823d"></a><br/></td></tr>
<tr class="memitem:gae9f3cde0162d4864f3cc1097ff3e7aec"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gae9f3cde0162d4864f3cc1097ff3e7aec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dicom__group.html#gae9f3cde0162d4864f3cc1097ff3e7aec">read_dicom</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:gae9f3cde0162d4864f3cc1097ff3e7aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">DICOMデータを画像コンテナに読み込む  <a href="group__dicom__group.html#gae9f3cde0162d4864f3cc1097ff3e7aec"></a><br/></td></tr>
<tr class="memitem:ga41b3d770e4f6d540891995fbd05dca5b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga41b3d770e4f6d540891995fbd05dca5b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__gif__group.html#ga41b3d770e4f6d540891995fbd05dca5b">read_gif</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga41b3d770e4f6d540891995fbd05dca5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GIF画像をMISTコンテナに読み込む  <a href="group__image__gif__group.html#ga41b3d770e4f6d540891995fbd05dca5b"></a><br/></td></tr>
<tr class="memitem:gaf26344e08b2a0e8a5c0c8b8f8ad92b5c"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaf26344e08b2a0e8a5c0c8b8f8ad92b5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__gif__group.html#gaf26344e08b2a0e8a5c0c8b8f8ad92b5c">read_gif</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gaf26344e08b2a0e8a5c0c8b8f8ad92b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GIF画像をMISTコンテナに読み込む  <a href="group__image__gif__group.html#gaf26344e08b2a0e8a5c0c8b8f8ad92b5c"></a><br/></td></tr>
<tr class="memitem:ga753d074332158a04c160ab1c29182967"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga753d074332158a04c160ab1c29182967"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__group.html#ga753d074332158a04c160ab1c29182967">read_image</a> (<a class="el" href="classmist_1_1array2.html">mist::array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga753d074332158a04c160ab1c29182967"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPEG，TIFF，PNG，BMP，PNM，GIF 画像を拡張子に基づいてMISTコンテナに読み込む  <a href="group__image__group.html#ga753d074332158a04c160ab1c29182967"></a><br/></td></tr>
<tr class="memitem:ga001405abc0f5202cc0c9fc49a6ea3617"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga001405abc0f5202cc0c9fc49a6ea3617"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__group.html#ga001405abc0f5202cc0c9fc49a6ea3617">read_image</a> (<a class="el" href="classmist_1_1array2.html">mist::array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga001405abc0f5202cc0c9fc49a6ea3617"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPEG，TIFF，PNG，BMP，PNM，GIF 画像を拡張子に基づいてMISTコンテナに読み込む  <a href="group__image__group.html#ga001405abc0f5202cc0c9fc49a6ea3617"></a><br/></td></tr>
<tr class="memitem:ga0b247072df9e69c7ddddac0f60af66b2"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga0b247072df9e69c7ddddac0f60af66b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__group.html#ga0b247072df9e69c7ddddac0f60af66b2">write_image</a> (const <a class="el" href="classmist_1_1array2.html">mist::array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga0b247072df9e69c7ddddac0f60af66b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をTIFF形式でJPEG，TIFF，PNG，BMP，PNM，GIF 画像形式でファイルに出力する  <a href="group__image__group.html#ga0b247072df9e69c7ddddac0f60af66b2"></a><br/></td></tr>
<tr class="memitem:ga1b6870eb57258c306d8950e151755767"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga1b6870eb57258c306d8950e151755767"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__group.html#ga1b6870eb57258c306d8950e151755767">write_image</a> (const <a class="el" href="classmist_1_1array2.html">mist::array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga1b6870eb57258c306d8950e151755767"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をTIFF形式でJPEG，TIFF，PNG，BMP，PNM，GIF 画像形式でファイルに出力する  <a href="group__image__group.html#ga1b6870eb57258c306d8950e151755767"></a><br/></td></tr>
<tr class="memitem:gab118838f9b8a138ca28ab443692f6588"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gab118838f9b8a138ca28ab443692f6588"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg__group.html#gab118838f9b8a138ca28ab443692f6588">read_jpeg</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:gab118838f9b8a138ca28ab443692f6588"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPEG画像をMISTコンテナに読み込む  <a href="group__image__jpeg__group.html#gab118838f9b8a138ca28ab443692f6588"></a><br/></td></tr>
<tr class="memitem:ga27e9e380d70eb60aa370d30936dfda59"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga27e9e380d70eb60aa370d30936dfda59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg__group.html#ga27e9e380d70eb60aa370d30936dfda59">read_jpeg</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga27e9e380d70eb60aa370d30936dfda59"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPEG画像をMISTコンテナに読み込む  <a href="group__image__jpeg__group.html#ga27e9e380d70eb60aa370d30936dfda59"></a><br/></td></tr>
<tr class="memitem:ga945a77c07442858663ab07cfc90a48b4"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga945a77c07442858663ab07cfc90a48b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg__group.html#ga945a77c07442858663ab07cfc90a48b4">write_jpeg</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, int quality=100)</td></tr>
<tr class="memdesc:ga945a77c07442858663ab07cfc90a48b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をJPEG形式でファイルに出力する  <a href="group__image__jpeg__group.html#ga945a77c07442858663ab07cfc90a48b4"></a><br/></td></tr>
<tr class="memitem:ga03435bd3790b76c2052019c533ad08ec"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga03435bd3790b76c2052019c533ad08ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg__group.html#ga03435bd3790b76c2052019c533ad08ec">write_jpeg</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, int quality=100)</td></tr>
<tr class="memdesc:ga03435bd3790b76c2052019c533ad08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をJPEG形式でファイルに出力する  <a href="group__image__jpeg__group.html#ga03435bd3790b76c2052019c533ad08ec"></a><br/></td></tr>
<tr class="memitem:ga7134317b470af9a4abf3e88d1e60c929"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga7134317b470af9a4abf3e88d1e60c929"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg2000__group.html#ga7134317b470af9a4abf3e88d1e60c929">read_jpeg2000</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga7134317b470af9a4abf3e88d1e60c929"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPEG2000画像をMISTコンテナに読み込む  <a href="group__image__jpeg2000__group.html#ga7134317b470af9a4abf3e88d1e60c929"></a><br/></td></tr>
<tr class="memitem:gaf3c98a41710f72d25b809566446c4812"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaf3c98a41710f72d25b809566446c4812"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg2000__group.html#gaf3c98a41710f72d25b809566446c4812">read_jpeg2000</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gaf3c98a41710f72d25b809566446c4812"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPEG2000画像をMISTコンテナに読み込む  <a href="group__image__jpeg2000__group.html#gaf3c98a41710f72d25b809566446c4812"></a><br/></td></tr>
<tr class="memitem:ga4d3f184ef4992ee86254135dda155a11"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga4d3f184ef4992ee86254135dda155a11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg2000__group.html#ga4d3f184ef4992ee86254135dda155a11">write_jpeg2000</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, double compression_level=0)</td></tr>
<tr class="memdesc:ga4d3f184ef4992ee86254135dda155a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をJPEG2000形式でファイルに出力する  <a href="group__image__jpeg2000__group.html#ga4d3f184ef4992ee86254135dda155a11"></a><br/></td></tr>
<tr class="memitem:ga5af92a0c05b10884c0689b1f75b19eca"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga5af92a0c05b10884c0689b1f75b19eca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__jpeg2000__group.html#ga5af92a0c05b10884c0689b1f75b19eca">write_jpeg2000</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, double compression_level=0)</td></tr>
<tr class="memdesc:ga5af92a0c05b10884c0689b1f75b19eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をJPEG2000形式でファイルに出力する  <a href="group__image__jpeg2000__group.html#ga5af92a0c05b10884c0689b1f75b19eca"></a><br/></td></tr>
<tr class="memitem:gaf1a692dd953f1dd975ab3aba6a95d338"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename A &gt; class Array, class Allocator &gt; </td></tr>
<tr class="memitem:gaf1a692dd953f1dd975ab3aba6a95d338"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lines__data__group.html#gaf1a692dd953f1dd975ab3aba6a95d338">read_lines</a> (Array&lt; std::string, Allocator &gt; &amp;lines, const std::string &amp;filename)</td></tr>
<tr class="memdesc:gaf1a692dd953f1dd975ab3aba6a95d338"><td class="mdescLeft">&#160;</td><td class="mdescRight">改行区切りのファイルをSTLコンテナに読み込む  <a href="group__lines__data__group.html#gaf1a692dd953f1dd975ab3aba6a95d338"></a><br/></td></tr>
<tr class="memitem:gae70c41a96b1ee66e7c58ceec703c1180"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename A &gt; class Array, class Allocator &gt; </td></tr>
<tr class="memitem:gae70c41a96b1ee66e7c58ceec703c1180"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lines__data__group.html#gae70c41a96b1ee66e7c58ceec703c1180">read_lines</a> (Array&lt; std::string, Allocator &gt; &amp;lines, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gae70c41a96b1ee66e7c58ceec703c1180"><td class="mdescLeft">&#160;</td><td class="mdescRight">改行区切りのファイルをSTLコンテナに読み込む  <a href="group__lines__data__group.html#gae70c41a96b1ee66e7c58ceec703c1180"></a><br/></td></tr>
<tr class="memitem:ga69182a7263b08773bdf86d8ceed6cef1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga69182a7263b08773bdf86d8ceed6cef1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#ga69182a7263b08773bdf86d8ceed6cef1">read_mqo</a> (std::vector&lt; <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &gt; &amp;facet_lists, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga69182a7263b08773bdf86d8ceed6cef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metasequoia形式のファイルからポリゴンデータを読み込む  <a href="group__cad__mqo__group.html#ga69182a7263b08773bdf86d8ceed6cef1"></a><br/></td></tr>
<tr class="memitem:ga641b3f4c99580c85d5400861c08054a2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga641b3f4c99580c85d5400861c08054a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#ga641b3f4c99580c85d5400861c08054a2">read_mqo</a> (std::vector&lt; <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &gt; &amp;facet_lists, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga641b3f4c99580c85d5400861c08054a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metasequoia形式のファイルからポリゴンデータを読み込む  <a href="group__cad__mqo__group.html#ga641b3f4c99580c85d5400861c08054a2"></a><br/></td></tr>
<tr class="memitem:ga892d648cb8fc1fdb30532d33372c8f7b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga892d648cb8fc1fdb30532d33372c8f7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#ga892d648cb8fc1fdb30532d33372c8f7b">read_mqo</a> (<a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga892d648cb8fc1fdb30532d33372c8f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metasequoia形式のファイルからポリゴンデータを読み込む  <a href="group__cad__mqo__group.html#ga892d648cb8fc1fdb30532d33372c8f7b"></a><br/></td></tr>
<tr class="memitem:gac596f7aa7e4511137510e7740ee07021"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac596f7aa7e4511137510e7740ee07021"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#gac596f7aa7e4511137510e7740ee07021">read_mqo</a> (<a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gac596f7aa7e4511137510e7740ee07021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metasequoia形式のファイルからポリゴンデータを読み込む  <a href="group__cad__mqo__group.html#gac596f7aa7e4511137510e7740ee07021"></a><br/></td></tr>
<tr class="memitem:ga41c2673bc0846670dec6b38ae9524024"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga41c2673bc0846670dec6b38ae9524024"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#ga41c2673bc0846670dec6b38ae9524024">write_mqo</a> (const std::vector&lt; <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &gt; &amp;facet_lists, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga41c2673bc0846670dec6b38ae9524024"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴンデータをMetasequoia形式で出力する  <a href="group__cad__mqo__group.html#ga41c2673bc0846670dec6b38ae9524024"></a><br/></td></tr>
<tr class="memitem:ga117953f522a46a796be9921eb910ac7a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga117953f522a46a796be9921eb910ac7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#ga117953f522a46a796be9921eb910ac7a">write_mqo</a> (const std::vector&lt; <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &gt; &amp;facet_lists, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga117953f522a46a796be9921eb910ac7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴンデータをMetasequoia形式で出力する  <a href="group__cad__mqo__group.html#ga117953f522a46a796be9921eb910ac7a"></a><br/></td></tr>
<tr class="memitem:ga21a06458f6343d2db2fee45f731f2649"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga21a06458f6343d2db2fee45f731f2649"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#ga21a06458f6343d2db2fee45f731f2649">write_mqo</a> (const <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga21a06458f6343d2db2fee45f731f2649"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴンデータをMetasequoia形式で出力する  <a href="group__cad__mqo__group.html#ga21a06458f6343d2db2fee45f731f2649"></a><br/></td></tr>
<tr class="memitem:ga747affb8da6121c2a462c2ff4cfa9c16"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga747affb8da6121c2a462c2ff4cfa9c16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__mqo__group.html#ga747affb8da6121c2a462c2ff4cfa9c16">write_mqo</a> (const <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga747affb8da6121c2a462c2ff4cfa9c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴンデータをMetasequoia形式で出力する  <a href="group__cad__mqo__group.html#ga747affb8da6121c2a462c2ff4cfa9c16"></a><br/></td></tr>
<tr class="memitem:ga52551ab07451336b9527f4667df925cc"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga52551ab07451336b9527f4667df925cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__png__group.html#ga52551ab07451336b9527f4667df925cc">read_png</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga52551ab07451336b9527f4667df925cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PNG画像をMISTコンテナに読み込む  <a href="group__image__png__group.html#ga52551ab07451336b9527f4667df925cc"></a><br/></td></tr>
<tr class="memitem:gaa9461efc80789d9d220a31ec48d8e307"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaa9461efc80789d9d220a31ec48d8e307"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__png__group.html#gaa9461efc80789d9d220a31ec48d8e307">read_png</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gaa9461efc80789d9d220a31ec48d8e307"><td class="mdescLeft">&#160;</td><td class="mdescRight">PNG画像をMISTコンテナに読み込む  <a href="group__image__png__group.html#gaa9461efc80789d9d220a31ec48d8e307"></a><br/></td></tr>
<tr class="memitem:gab09435cc82204b19da058611960ee819"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gab09435cc82204b19da058611960ee819"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__png__group.html#gab09435cc82204b19da058611960ee819">write_png</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, int compression_level=6)</td></tr>
<tr class="memdesc:gab09435cc82204b19da058611960ee819"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をPNG形式でファイルに出力する  <a href="group__image__png__group.html#gab09435cc82204b19da058611960ee819"></a><br/></td></tr>
<tr class="memitem:ga6e1d7d2e15d39ce8c41a5738dfdfe57c"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga6e1d7d2e15d39ce8c41a5738dfdfe57c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__png__group.html#ga6e1d7d2e15d39ce8c41a5738dfdfe57c">write_png</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, int compression_level=6)</td></tr>
<tr class="memdesc:ga6e1d7d2e15d39ce8c41a5738dfdfe57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をPNG形式でファイルに出力する  <a href="group__image__png__group.html#ga6e1d7d2e15d39ce8c41a5738dfdfe57c"></a><br/></td></tr>
<tr class="memitem:gad97d66fc27f5f72526aa05439668105e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gad97d66fc27f5f72526aa05439668105e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__pnm__group.html#gad97d66fc27f5f72526aa05439668105e">read_pnm</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type level=255)</td></tr>
<tr class="memdesc:gad97d66fc27f5f72526aa05439668105e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PNM画像をMISTコンテナに読み込む  <a href="group__image__pnm__group.html#gad97d66fc27f5f72526aa05439668105e"></a><br/></td></tr>
<tr class="memitem:gaafeb86f0cb2f3842dff92fefb8256b85"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaafeb86f0cb2f3842dff92fefb8256b85"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__pnm__group.html#gaafeb86f0cb2f3842dff92fefb8256b85">read_pnm</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type level=255)</td></tr>
<tr class="memdesc:gaafeb86f0cb2f3842dff92fefb8256b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">PNM画像をMISTコンテナに読み込む  <a href="group__image__pnm__group.html#gaafeb86f0cb2f3842dff92fefb8256b85"></a><br/></td></tr>
<tr class="memitem:ga0ecb39ac67566de19deb3ca7f5c0060b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga0ecb39ac67566de19deb3ca7f5c0060b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__pnm__group.html#ga0ecb39ac67566de19deb3ca7f5c0060b">write_pnm</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type pnm_type=6, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type level=255)</td></tr>
<tr class="memdesc:ga0ecb39ac67566de19deb3ca7f5c0060b"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をPNM形式でファイルに出力する  <a href="group__image__pnm__group.html#ga0ecb39ac67566de19deb3ca7f5c0060b"></a><br/></td></tr>
<tr class="memitem:ga0874ffc7b75914d2525b72412aa2b63e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga0874ffc7b75914d2525b72412aa2b63e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__pnm__group.html#ga0874ffc7b75914d2525b72412aa2b63e">write_pnm</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type pnm_type=6, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type level=255)</td></tr>
<tr class="memdesc:ga0874ffc7b75914d2525b72412aa2b63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をPNM形式でファイルに出力する  <a href="group__image__pnm__group.html#ga0874ffc7b75914d2525b72412aa2b63e"></a><br/></td></tr>
<tr class="memitem:gae10c8395b422903dba6a944e0214f367"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class ValueType , class Functor &gt; </td></tr>
<tr class="memitem:gae10c8395b422903dba6a944e0214f367"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#gae10c8395b422903dba6a944e0214f367">read_raw</a> (<a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, ValueType __dmy__, Functor callback)</td></tr>
<tr class="memdesc:gae10c8395b422903dba6a944e0214f367"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#gae10c8395b422903dba6a944e0214f367"></a><br/></td></tr>
<tr class="memitem:ga7d89abc77cf7d7928812036d3963b47e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class ValueType , class Functor &gt; </td></tr>
<tr class="memitem:ga7d89abc77cf7d7928812036d3963b47e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga7d89abc77cf7d7928812036d3963b47e">write_raw</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset, bool to_little_endian, ValueType __dmy__, Functor callback)</td></tr>
<tr class="memdesc:ga7d89abc77cf7d7928812036d3963b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナ内の画像を 無圧縮RAW 画像として出力する  <a href="group__image__raw__group.html#ga7d89abc77cf7d7928812036d3963b47e"></a><br/></td></tr>
<tr class="memitem:ga6ff8968348aae67b04d88727715d1c59"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class ValueType , class Functor &gt; </td></tr>
<tr class="memitem:ga6ff8968348aae67b04d88727715d1c59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga6ff8968348aae67b04d88727715d1c59">write_raw_gz</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset, bool to_little_endian, ValueType __dmy__, Functor callback)</td></tr>
<tr class="memdesc:ga6ff8968348aae67b04d88727715d1c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナ内の画像を GZ圧縮RAW 画像として出力する  <a href="group__image__raw__group.html#ga6ff8968348aae67b04d88727715d1c59"></a><br/></td></tr>
<tr class="memitem:ga167e1b2cf4e4e43b5634a9b37f0aa79f"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga167e1b2cf4e4e43b5634a9b37f0aa79f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga167e1b2cf4e4e43b5634a9b37f0aa79f">read_raw</a> (<a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, Functor callback)</td></tr>
<tr class="memdesc:ga167e1b2cf4e4e43b5634a9b37f0aa79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga167e1b2cf4e4e43b5634a9b37f0aa79f"></a><br/></td></tr>
<tr class="memitem:ga0cf056bd9f983873e07f39ae61e1fa74"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga0cf056bd9f983873e07f39ae61e1fa74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga0cf056bd9f983873e07f39ae61e1fa74">write_raw</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset, bool to_little_endian, Functor callback)</td></tr>
<tr class="memdesc:ga0cf056bd9f983873e07f39ae61e1fa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナ内の画像を 無圧縮RAW 画像として出力する  <a href="group__image__raw__group.html#ga0cf056bd9f983873e07f39ae61e1fa74"></a><br/></td></tr>
<tr class="memitem:ga4794ac9647a998a6656a090d0d10dff0"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga4794ac9647a998a6656a090d0d10dff0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga4794ac9647a998a6656a090d0d10dff0">write_raw_gz</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset, bool to_little_endian, Functor callback)</td></tr>
<tr class="memdesc:ga4794ac9647a998a6656a090d0d10dff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナ内の画像を GZ圧縮RAW 画像として出力する  <a href="group__image__raw__group.html#ga4794ac9647a998a6656a090d0d10dff0"></a><br/></td></tr>
<tr class="memitem:ga0ff55f0a2c90bce107706d2fa34cc708"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga0ff55f0a2c90bce107706d2fa34cc708"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga0ff55f0a2c90bce107706d2fa34cc708">read_raw</a> (<a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset=0, bool from_little_endian=false)</td></tr>
<tr class="memdesc:ga0ff55f0a2c90bce107706d2fa34cc708"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga0ff55f0a2c90bce107706d2fa34cc708"></a><br/></td></tr>
<tr class="memitem:ga250d7c45fcf34891a2778fc6b16bbecf"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga250d7c45fcf34891a2778fc6b16bbecf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga250d7c45fcf34891a2778fc6b16bbecf">write_raw</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset=0, bool to_little_endian=false)</td></tr>
<tr class="memdesc:ga250d7c45fcf34891a2778fc6b16bbecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナ内の画像を 無圧縮RAW 画像として出力する  <a href="group__image__raw__group.html#ga250d7c45fcf34891a2778fc6b16bbecf"></a><br/></td></tr>
<tr class="memitem:gaf0eae253c4d769143fba1877c1e31930"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaf0eae253c4d769143fba1877c1e31930"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#gaf0eae253c4d769143fba1877c1e31930">write_raw_gz</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type offset=typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::value_type(0), bool to_little_endian=false)</td></tr>
<tr class="memdesc:gaf0eae253c4d769143fba1877c1e31930"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナ内の画像を GZ圧縮RAW 画像として出力する  <a href="group__image__raw__group.html#gaf0eae253c4d769143fba1877c1e31930"></a><br/></td></tr>
<tr class="memitem:ga939d72732c9d524c7477be51022abe46"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class ValueType , class Functor &gt; </td></tr>
<tr class="memitem:ga939d72732c9d524c7477be51022abe46"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga939d72732c9d524c7477be51022abe46">read_raw</a> (<a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt;::size_type w, double x, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, ValueType __dmy__, Functor callback)</td></tr>
<tr class="memdesc:ga939d72732c9d524c7477be51022abe46"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga939d72732c9d524c7477be51022abe46"></a><br/></td></tr>
<tr class="memitem:ga163f589ce6ba7b4e0bf996314abc0e41"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga163f589ce6ba7b4e0bf996314abc0e41"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga163f589ce6ba7b4e0bf996314abc0e41">read_raw</a> (<a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt;::size_type w, double x, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, Functor callback)</td></tr>
<tr class="memdesc:ga163f589ce6ba7b4e0bf996314abc0e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga163f589ce6ba7b4e0bf996314abc0e41"></a><br/></td></tr>
<tr class="memitem:ga457045ee7950c3238891932e0b4e2efa"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga457045ee7950c3238891932e0b4e2efa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga457045ee7950c3238891932e0b4e2efa">read_raw</a> (<a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt;::size_type w, double x=1.0, typename <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt;::value_type offset=0, bool from_little_endian=false)</td></tr>
<tr class="memdesc:ga457045ee7950c3238891932e0b4e2efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga457045ee7950c3238891932e0b4e2efa"></a><br/></td></tr>
<tr class="memitem:ga8fbba41c7f6bae50c804965412bf635e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class ValueType , class Functor &gt; </td></tr>
<tr class="memitem:ga8fbba41c7f6bae50c804965412bf635e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga8fbba41c7f6bae50c804965412bf635e">read_raw</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type h, double x, double y, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, ValueType __dmy__, Functor callback)</td></tr>
<tr class="memdesc:ga8fbba41c7f6bae50c804965412bf635e"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga8fbba41c7f6bae50c804965412bf635e"></a><br/></td></tr>
<tr class="memitem:ga2fcfa518b1f67f0f56a8079a2c906f62"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga2fcfa518b1f67f0f56a8079a2c906f62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga2fcfa518b1f67f0f56a8079a2c906f62">read_raw</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type h, double x, double y, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, Functor callback)</td></tr>
<tr class="memdesc:ga2fcfa518b1f67f0f56a8079a2c906f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga2fcfa518b1f67f0f56a8079a2c906f62"></a><br/></td></tr>
<tr class="memitem:ga7711026977c14725bca1e188a7f2e0c2"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga7711026977c14725bca1e188a7f2e0c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga7711026977c14725bca1e188a7f2e0c2">read_raw</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type h, double x=1.0, double y=1.0, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::value_type offset=0, bool from_little_endian=false)</td></tr>
<tr class="memdesc:ga7711026977c14725bca1e188a7f2e0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga7711026977c14725bca1e188a7f2e0c2"></a><br/></td></tr>
<tr class="memitem:ga4089ac188873c089f83188ff900c977a"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class ValueType , class Functor &gt; </td></tr>
<tr class="memitem:ga4089ac188873c089f83188ff900c977a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga4089ac188873c089f83188ff900c977a">read_raw</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type h, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type d, double x, double y, double z, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, ValueType __dmy__, Functor callback)</td></tr>
<tr class="memdesc:ga4089ac188873c089f83188ff900c977a"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga4089ac188873c089f83188ff900c977a"></a><br/></td></tr>
<tr class="memitem:ga85a166992ffc87ffad277da1163801b3"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator , class Functor &gt; </td></tr>
<tr class="memitem:ga85a166992ffc87ffad277da1163801b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga85a166992ffc87ffad277da1163801b3">read_raw</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type h, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type d, double x, double y, double z, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type offset, bool from_little_endian, Functor callback)</td></tr>
<tr class="memdesc:ga85a166992ffc87ffad277da1163801b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga85a166992ffc87ffad277da1163801b3"></a><br/></td></tr>
<tr class="memitem:ga9215330ae66f8fa0b774a9acde503aa3"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga9215330ae66f8fa0b774a9acde503aa3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__raw__group.html#ga9215330ae66f8fa0b774a9acde503aa3">read_raw</a> (<a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type w, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type h, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::size_type d, double x=1.0, double y=1.0, double z=1.0, typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type offset=typename <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt;::value_type(0), bool from_little_endian=false)</td></tr>
<tr class="memdesc:ga9215330ae66f8fa0b774a9acde503aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">無圧縮RAW，GZ圧縮RAW 画像をMISTコンテナに読み込む  <a href="group__image__raw__group.html#ga9215330ae66f8fa0b774a9acde503aa3"></a><br/></td></tr>
<tr class="memitem:ga9a693bb830efe008c1794968dffc433c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9a693bb830efe008c1794968dffc433c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__stl__group.html#ga9a693bb830efe008c1794968dffc433c">read_stl</a> (<a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga9a693bb830efe008c1794968dffc433c"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL（ASCII，バイナリ）形式のファイルからポリゴンデータを読み込む  <a href="group__cad__stl__group.html#ga9a693bb830efe008c1794968dffc433c"></a><br/></td></tr>
<tr class="memitem:ga81fe990fde7a6679cd4a1d3ede2feab1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81fe990fde7a6679cd4a1d3ede2feab1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__stl__group.html#ga81fe990fde7a6679cd4a1d3ede2feab1">read_stl</a> (<a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga81fe990fde7a6679cd4a1d3ede2feab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL（ASCII，バイナリ）形式のファイルからポリゴンデータを読み込む  <a href="group__cad__stl__group.html#ga81fe990fde7a6679cd4a1d3ede2feab1"></a><br/></td></tr>
<tr class="memitem:ga6d72ac8c61cf66e355516511f50ebaff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6d72ac8c61cf66e355516511f50ebaff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__stl__group.html#ga6d72ac8c61cf66e355516511f50ebaff">write_stl</a> (const <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::wstring &amp;filename, bool use_ascii_format=true)</td></tr>
<tr class="memdesc:ga6d72ac8c61cf66e355516511f50ebaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴンデータをSTL（ASCII，バイナリ）形式で出力する  <a href="group__cad__stl__group.html#ga6d72ac8c61cf66e355516511f50ebaff"></a><br/></td></tr>
<tr class="memitem:gacd2488ed1a1e20d3b0e5a7590d429ca2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacd2488ed1a1e20d3b0e5a7590d429ca2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cad__stl__group.html#gacd2488ed1a1e20d3b0e5a7590d429ca2">write_stl</a> (const <a class="el" href="classmist_1_1facet__list.html">facet_list</a>&lt; T &gt; &amp;facets, const std::string &amp;filename, bool use_ascii_format=true)</td></tr>
<tr class="memdesc:gacd2488ed1a1e20d3b0e5a7590d429ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ポリゴンデータをSTL（ASCII，バイナリ）形式で出力する  <a href="group__cad__stl__group.html#gacd2488ed1a1e20d3b0e5a7590d429ca2"></a><br/></td></tr>
<tr class="memitem:ga8bec3835bede9a92d3233b70388b3e26"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga8bec3835bede9a92d3233b70388b3e26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tga__group.html#ga8bec3835bede9a92d3233b70388b3e26">read_tga</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga8bec3835bede9a92d3233b70388b3e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">TGA画像をMISTコンテナに読み込む  <a href="group__image__tga__group.html#ga8bec3835bede9a92d3233b70388b3e26"></a><br/></td></tr>
<tr class="memitem:ga4d649516d505f02037cf339bb55fcd24"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga4d649516d505f02037cf339bb55fcd24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tga__group.html#ga4d649516d505f02037cf339bb55fcd24">read_tga</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:ga4d649516d505f02037cf339bb55fcd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">TGA画像をMISTコンテナに読み込む  <a href="group__image__tga__group.html#ga4d649516d505f02037cf339bb55fcd24"></a><br/></td></tr>
<tr class="memitem:gadfdcb6ebb9ea381eb0d5f6550c6c9471"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gadfdcb6ebb9ea381eb0d5f6550c6c9471"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tga__group.html#gadfdcb6ebb9ea381eb0d5f6550c6c9471">write_tga</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type tga_bits=32, bool is_encode_RLE=true)</td></tr>
<tr class="memdesc:gadfdcb6ebb9ea381eb0d5f6550c6c9471"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をTGA形式でファイルに出力する  <a href="group__image__tga__group.html#gadfdcb6ebb9ea381eb0d5f6550c6c9471"></a><br/></td></tr>
<tr class="memitem:ga09a6472ceece709a3c7eb00be35b9e4f"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga09a6472ceece709a3c7eb00be35b9e4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tga__group.html#ga09a6472ceece709a3c7eb00be35b9e4f">write_tga</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::size_type tga_bits=32, bool is_encode_RLE=true)</td></tr>
<tr class="memdesc:ga09a6472ceece709a3c7eb00be35b9e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をTGA形式でファイルに出力する  <a href="group__image__tga__group.html#ga09a6472ceece709a3c7eb00be35b9e4f"></a><br/></td></tr>
<tr class="memitem:gaed6bb21f0e0e0dd2bf59d198c2b2d0a9"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaed6bb21f0e0e0dd2bf59d198c2b2d0a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tiff__group.html#gaed6bb21f0e0e0dd2bf59d198c2b2d0a9">read_tiff</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename)</td></tr>
<tr class="memdesc:gaed6bb21f0e0e0dd2bf59d198c2b2d0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">TIFF画像をMISTコンテナに読み込む  <a href="group__image__tiff__group.html#gaed6bb21f0e0e0dd2bf59d198c2b2d0a9"></a><br/></td></tr>
<tr class="memitem:gac1f56047db2d6cfc5fad0f815ae58b8e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gac1f56047db2d6cfc5fad0f815ae58b8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tiff__group.html#gac1f56047db2d6cfc5fad0f815ae58b8e">read_tiff</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gac1f56047db2d6cfc5fad0f815ae58b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">TIFF画像をMISTコンテナに読み込む  <a href="group__image__tiff__group.html#gac1f56047db2d6cfc5fad0f815ae58b8e"></a><br/></td></tr>
<tr class="memitem:gad9ec0d98308ccabd5c25aacb5225c28b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gad9ec0d98308ccabd5c25aacb5225c28b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tiff__group.html#gad9ec0d98308ccabd5c25aacb5225c28b">write_tiff</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::string &amp;filename, bool use_lzw_compression=<a class="el" href="group__config__group.html#ga0a9574c0f5d59f3864181e311acccb38">_LZW_COMPRESSION_SUPPORT_</a>)</td></tr>
<tr class="memdesc:gad9ec0d98308ccabd5c25aacb5225c28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をTIFF形式でファイルに出力する  <a href="group__image__tiff__group.html#gad9ec0d98308ccabd5c25aacb5225c28b"></a><br/></td></tr>
<tr class="memitem:ga2ad242e5106004783f84323aa636dbf6"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga2ad242e5106004783f84323aa636dbf6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__image__tiff__group.html#ga2ad242e5106004783f84323aa636dbf6">write_tiff</a> (const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;image, const std::wstring &amp;filename, bool use_lzw_compression=<a class="el" href="group__config__group.html#ga0a9574c0f5d59f3864181e311acccb38">_LZW_COMPRESSION_SUPPORT_</a>)</td></tr>
<tr class="memdesc:ga2ad242e5106004783f84323aa636dbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナの画像をTIFF形式でファイルに出力する  <a href="group__image__tiff__group.html#ga2ad242e5106004783f84323aa636dbf6"></a><br/></td></tr>
<tr class="memitem:gaaaceabf15a95e095a9ddf75e017c39f7"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gaaaceabf15a95e095a9ddf75e017c39f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__audio__wav__group.html#gaaaceabf15a95e095a9ddf75e017c39f7">read_wav</a> (<a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;sound, const std::string &amp;filename, unsigned int &amp;sampling_rate)</td></tr>
<tr class="memdesc:gaaaceabf15a95e095a9ddf75e017c39f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">WAVファイルから音声データををMISTコンテナに読み込む  <a href="group__audio__wav__group.html#gaaaceabf15a95e095a9ddf75e017c39f7"></a><br/></td></tr>
<tr class="memitem:gac0960f0bfc89fdecb87496573ec33a42"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gac0960f0bfc89fdecb87496573ec33a42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__audio__wav__group.html#gac0960f0bfc89fdecb87496573ec33a42">read_wav</a> (<a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;sound, const std::wstring &amp;filename, unsigned int &amp;sampling_rate)</td></tr>
<tr class="memdesc:gac0960f0bfc89fdecb87496573ec33a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">WAVファイルから音声データををMISTコンテナに読み込む  <a href="group__audio__wav__group.html#gac0960f0bfc89fdecb87496573ec33a42"></a><br/></td></tr>
<tr class="memitem:ga3df7a22c9cd36a0afd64c10a975f5f21"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga3df7a22c9cd36a0afd64c10a975f5f21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__audio__wav__group.html#ga3df7a22c9cd36a0afd64c10a975f5f21">read_wav</a> (<a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;sound, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ga3df7a22c9cd36a0afd64c10a975f5f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">WAVファイルから音声データををMISTコンテナに読み込む  <a href="group__audio__wav__group.html#ga3df7a22c9cd36a0afd64c10a975f5f21"></a><br/></td></tr>
<tr class="memitem:gac704f5f0ad2225207c8c67ace6b8d85d"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:gac704f5f0ad2225207c8c67ace6b8d85d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__audio__wav__group.html#gac704f5f0ad2225207c8c67ace6b8d85d">read_wav</a> (<a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;sound, const std::wstring &amp;filename)</td></tr>
<tr class="memdesc:gac704f5f0ad2225207c8c67ace6b8d85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">WAVファイルから音声データををMISTコンテナに読み込む  <a href="group__audio__wav__group.html#gac704f5f0ad2225207c8c67ace6b8d85d"></a><br/></td></tr>
<tr class="memitem:ga441184b6f414d802d09e9008debf31c2"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga441184b6f414d802d09e9008debf31c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__audio__wav__group.html#ga441184b6f414d802d09e9008debf31c2">write_wav</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;sound, const std::string &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::size_type wav_bits, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::size_type sampling_rate)</td></tr>
<tr class="memdesc:ga441184b6f414d802d09e9008debf31c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナのデータをWAVファイルへ出力する  <a href="group__audio__wav__group.html#ga441184b6f414d802d09e9008debf31c2"></a><br/></td></tr>
<tr class="memitem:ga01384af36c55bb6b757db4b53a4c9737"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga01384af36c55bb6b757db4b53a4c9737"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__audio__wav__group.html#ga01384af36c55bb6b757db4b53a4c9737">write_wav</a> (const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;sound, const std::wstring &amp;filename, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::size_type wav_bits, typename <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt;::size_type sampling_rate)</td></tr>
<tr class="memdesc:ga01384af36c55bb6b757db4b53a4c9737"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISTコンテナのデータをWAVファイルへ出力する  <a href="group__audio__wav__group.html#ga01384af36c55bb6b757db4b53a4c9737"></a><br/></td></tr>
<tr class="memitem:ga35f3e11f9c6d1a5d230dfd67144a46cf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga35f3e11f9c6d1a5d230dfd67144a46cf"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__limits__group.html#ga35f3e11f9c6d1a5d230dfd67144a46cf">limits_min_max</a> (const T &amp;v, const T &amp;min, const T &amp;max)</td></tr>
<tr class="memdesc:ga35f3e11f9c6d1a5d230dfd67144a46cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力されたデータを min から max の範囲に変換する  <a href="group__limits__group.html#ga35f3e11f9c6d1a5d230dfd67144a46cf"></a><br/></td></tr>
<tr class="memitem:ga1464929b75be132ea42ef9830bdba8c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga1464929b75be132ea42ef9830bdba8c6"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__limits__group.html#ga1464929b75be132ea42ef9830bdba8c6">limits_0_255</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ga1464929b75be132ea42ef9830bdba8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力されたデータを 0 から 255 の範囲に変換する  <a href="group__limits__group.html#ga1464929b75be132ea42ef9830bdba8c6"></a><br/></td></tr>
<tr class="memitem:a91e2273b32d5b97d2d06d37a4037c757"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a91e2273b32d5b97d2d06d37a4037c757"><td class="memTemplItemLeft" align="right" valign="top">inline::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a91e2273b32d5b97d2d06d37a4037c757">operator&lt;&lt;</a> (::std::ostream &amp;out, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m)</td></tr>
<tr class="memdesc:a91e2273b32d5b97d2d06d37a4037c757"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，行列内の要素を整形して出力する  <a href="#a91e2273b32d5b97d2d06d37a4037c757"></a><br/></td></tr>
<tr class="memitem:ac3a6973bb47d8ca035824599240b0e8e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ac3a6973bb47d8ca035824599240b0e8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ac3a6973bb47d8ca035824599240b0e8e">operator+</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m1, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m2)</td></tr>
<tr class="memdesc:ac3a6973bb47d8ca035824599240b0e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">足し算  <a href="#ac3a6973bb47d8ca035824599240b0e8e"></a><br/></td></tr>
<tr class="memitem:afe4b92258c37027b49b0a219fcd62e92"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:afe4b92258c37027b49b0a219fcd62e92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#afe4b92258c37027b49b0a219fcd62e92">operator-</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m1, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m2)</td></tr>
<tr class="memdesc:afe4b92258c37027b49b0a219fcd62e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">引き算  <a href="#afe4b92258c37027b49b0a219fcd62e92"></a><br/></td></tr>
<tr class="memitem:a0790291fd486c1f783c7dac7bbde12c2"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a0790291fd486c1f783c7dac7bbde12c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a0790291fd486c1f783c7dac7bbde12c2">operator*</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m1, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m2)</td></tr>
<tr class="memdesc:a0790291fd486c1f783c7dac7bbde12c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">掛け算  <a href="#a0790291fd486c1f783c7dac7bbde12c2"></a><br/></td></tr>
<tr class="memitem:a466c47241a60a5af94c7a6df2889f67e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a466c47241a60a5af94c7a6df2889f67e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a466c47241a60a5af94c7a6df2889f67e">operator+</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m, typename <a class="el" href="structmist_1_1type__trait.html">type_trait</a>&lt; T &gt;::value_type val)</td></tr>
<tr class="memdesc:a466c47241a60a5af94c7a6df2889f67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">単位行列の定数倍との足し算  <a href="#a466c47241a60a5af94c7a6df2889f67e"></a><br/></td></tr>
<tr class="memitem:aeb25d48aff8ef3f633d301e6db75696b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:aeb25d48aff8ef3f633d301e6db75696b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#aeb25d48aff8ef3f633d301e6db75696b">operator+</a> (typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type val, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m)</td></tr>
<tr class="memdesc:aeb25d48aff8ef3f633d301e6db75696b"><td class="mdescLeft">&#160;</td><td class="mdescRight">定数との足し算  <a href="#aeb25d48aff8ef3f633d301e6db75696b"></a><br/></td></tr>
<tr class="memitem:acadf0c903a1232ba1c25e785a13aa53b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:acadf0c903a1232ba1c25e785a13aa53b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#acadf0c903a1232ba1c25e785a13aa53b">operator-</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m, typename <a class="el" href="structmist_1_1type__trait.html">type_trait</a>&lt; T &gt;::value_type val)</td></tr>
<tr class="memdesc:acadf0c903a1232ba1c25e785a13aa53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">定数との引き算  <a href="#acadf0c903a1232ba1c25e785a13aa53b"></a><br/></td></tr>
<tr class="memitem:a7ca5606a41b6033da4884567c28163ec"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a7ca5606a41b6033da4884567c28163ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a7ca5606a41b6033da4884567c28163ec">operator-</a> (typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type val, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m)</td></tr>
<tr class="memdesc:a7ca5606a41b6033da4884567c28163ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">定数との引き算  <a href="#a7ca5606a41b6033da4884567c28163ec"></a><br/></td></tr>
<tr class="memitem:a7bcf2817675a41959d87d536e864b3a1"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a7bcf2817675a41959d87d536e864b3a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a7bcf2817675a41959d87d536e864b3a1">operator*</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m, typename <a class="el" href="structmist_1_1type__trait.html">type_trait</a>&lt; T &gt;::value_type val)</td></tr>
<tr class="memdesc:a7bcf2817675a41959d87d536e864b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">定数との掛け算  <a href="#a7bcf2817675a41959d87d536e864b3a1"></a><br/></td></tr>
<tr class="memitem:a514da56f0a006923be7523ca346d506a"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a514da56f0a006923be7523ca346d506a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a514da56f0a006923be7523ca346d506a">operator*</a> (typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type val, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m)</td></tr>
<tr class="memdesc:a514da56f0a006923be7523ca346d506a"><td class="mdescLeft">&#160;</td><td class="mdescRight">定数との掛け算  <a href="#a514da56f0a006923be7523ca346d506a"></a><br/></td></tr>
<tr class="memitem:a9f3ff2cc7d439692dfb38b507443b7a7"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a9f3ff2cc7d439692dfb38b507443b7a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a9f3ff2cc7d439692dfb38b507443b7a7">operator/</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;m, typename <a class="el" href="structmist_1_1type__trait.html">type_trait</a>&lt; T &gt;::value_type val)</td></tr>
<tr class="memitem:a86de595cc64ee97e461132690b61fa37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a86de595cc64ee97e461132690b61fa37">cut_detection</a> (<a class="el" href="classmist_1_1video_1_1decoder.html">video::decoder</a> &amp;iv, std::vector&lt; int &gt; &amp;frame_indeces, size_t red_bin=8, size_t green_bin=8, size_t blue_bin=8, double threshold_of_similarity=0.95, ptrdiff_t number_of_between_frames=30)</td></tr>
<tr class="memdesc:a86de595cc64ee97e461132690b61fa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビデオストリームを入力し，ビデオ内のカット位置を検出する  <a href="#a86de595cc64ee97e461132690b61fa37"></a><br/></td></tr>
<tr class="memitem:ga28809be0c956f7387194e4d474ace7e3"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:ga28809be0c956f7387194e4d474ace7e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__minimization__group.html#ga28809be0c956f7387194e4d474ace7e3">enclose</a> (double &amp;a, double &amp;b, double &amp;c, double &amp;fa, double &amp;fb, double &amp;fc, Functor f, size_t max_iterations=100)</td></tr>
<tr class="memdesc:ga28809be0c956f7387194e4d474ace7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">f(x)の一次元探索において，極小値を与える x を囲む区間を決定する  <a href="group__minimization__group.html#ga28809be0c956f7387194e4d474ace7e3"></a><br/></td></tr>
<tr class="memitem:a502570f7489d976b2ead6749dccfb133"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a502570f7489d976b2ead6749dccfb133"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a502570f7489d976b2ead6749dccfb133">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;a)</td></tr>
<tr class="memdesc:a502570f7489d976b2ead6749dccfb133"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="#a502570f7489d976b2ead6749dccfb133"></a><br/></td></tr>
<tr class="memitem:add166b75cc203f6b542f4d6c6ca8293b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:add166b75cc203f6b542f4d6c6ca8293b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#add166b75cc203f6b542f4d6c6ca8293b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1array1.html">array1</a>&lt; T, Allocator &gt; &amp;a)</td></tr>
<tr class="memdesc:add166b75cc203f6b542f4d6c6ca8293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="#add166b75cc203f6b542f4d6c6ca8293b"></a><br/></td></tr>
<tr class="memitem:a77cc71d72e4e0689b1371fa426868853"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:a77cc71d72e4e0689b1371fa426868853"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a77cc71d72e4e0689b1371fa426868853">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;a)</td></tr>
<tr class="memdesc:a77cc71d72e4e0689b1371fa426868853"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="#a77cc71d72e4e0689b1371fa426868853"></a><br/></td></tr>
<tr class="memitem:af8edde19003a031bd76688042d598999"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:af8edde19003a031bd76688042d598999"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#af8edde19003a031bd76688042d598999">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1array3.html">array3</a>&lt; T, Allocator &gt; &amp;a)</td></tr>
<tr class="memdesc:af8edde19003a031bd76688042d598999"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，コンテナ内の要素を整形して出力する  <a href="#af8edde19003a031bd76688042d598999"></a><br/></td></tr>
<tr class="memitem:ga8e0ad06f1cb9445fb55535f3241e5e05"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga8e0ad06f1cb9445fb55535f3241e5e05"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mixture__group.html#ga8e0ad06f1cb9445fb55535f3241e5e05">estimate_mixture</a> (const Array &amp;rSamples, <a class="el" href="structmist_1_1mixture_1_1distribution.html">mixture::distribution</a> *opdp, size_t nSamples, size_t nComponents, size_t nMaxIteration, double tolerance, size_t &amp;nIteration)</td></tr>
<tr class="memdesc:ga8e0ad06f1cb9445fb55535f3241e5e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">データ系列から正規分布の混合分布を推定する  <a href="group__mixture__group.html#ga8e0ad06f1cb9445fb55535f3241e5e05"></a><br/></td></tr>
<tr class="memitem:gaacbd07e36084039b89fa5a48579fa7e5"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:gaacbd07e36084039b89fa5a48579fa7e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mixture__group.html#gaacbd07e36084039b89fa5a48579fa7e5">estimate_mixture</a> (const Array &amp;rSamples, <a class="el" href="structmist_1_1mixture_1_1distribution2.html">mixture::distribution2</a> *opdp, size_t nSamples, size_t nComponents, size_t nMaxIteration, double tolerance, size_t &amp;nIteration)</td></tr>
<tr class="memdesc:gaacbd07e36084039b89fa5a48579fa7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">データ系列から正規分布の混合分布を推定する  <a href="group__mixture__group.html#gaacbd07e36084039b89fa5a48579fa7e5"></a><br/></td></tr>
<tr class="memitem:gaaa950fd139a0a9b448da5563f150124c"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:gaaa950fd139a0a9b448da5563f150124c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mixture__group.html#gaaa950fd139a0a9b448da5563f150124c">estimate_mixture</a> (const Array1 &amp;rSamples, Array2 &amp;pdp, typename Array1::size_type nMaxIteration, double tolerance, typename Array1::size_type &amp;nIteration)</td></tr>
<tr class="memdesc:gaaa950fd139a0a9b448da5563f150124c"><td class="mdescLeft">&#160;</td><td class="mdescRight">データ系列から正規分布の混合分布を推定する  <a href="group__mixture__group.html#gaaa950fd139a0a9b448da5563f150124c"></a><br/></td></tr>
<tr class="memitem:ga5c52c04964dddcc4b4da604f9f9da108"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga5c52c04964dddcc4b4da604f9f9da108"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mixture__group.html#ga5c52c04964dddcc4b4da604f9f9da108">estimate_mixture</a> (const Array1 &amp;rSamples, Array2 &amp;pdp, typename Array1::size_type nMaxIteration, double tolerance)</td></tr>
<tr class="memdesc:ga5c52c04964dddcc4b4da604f9f9da108"><td class="mdescLeft">&#160;</td><td class="mdescRight">データ系列から1次元正規分布の混合分布を推定する  <a href="group__mixture__group.html#ga5c52c04964dddcc4b4da604f9f9da108"></a><br/></td></tr>
<tr class="memitem:ga501fbe8466f198add2e46c697eed0980"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga501fbe8466f198add2e46c697eed0980"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mixture__group.html#ga501fbe8466f198add2e46c697eed0980">estimate_mixture</a> (const Array &amp;rSamples, <a class="el" href="structmist_1_1mixture_1_1distribution.html">mixture::distribution</a> *pdp, typename Array::size_type nComponents, typename Array::size_type nMaxIteration, double tolerance)</td></tr>
<tr class="memdesc:ga501fbe8466f198add2e46c697eed0980"><td class="mdescLeft">&#160;</td><td class="mdescRight">データ系列から正規分布の混合分布を推定する  <a href="group__mixture__group.html#ga501fbe8466f198add2e46c697eed0980"></a><br/></td></tr>
<tr class="memitem:ga224870a424283b9fb51de47f16e5b5ff"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:ga224870a424283b9fb51de47f16e5b5ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mixture__group.html#ga224870a424283b9fb51de47f16e5b5ff">estimate_mixture</a> (const Array &amp;rSamples, <a class="el" href="structmist_1_1mixture_1_1distribution2.html">mixture::distribution2</a> *pdp, typename Array::size_type nComponents, typename Array::size_type nMaxIteration, double tolerance)</td></tr>
<tr class="memdesc:ga224870a424283b9fb51de47f16e5b5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">データ系列から2次元正規分布の混合分布を推定する  <a href="group__mixture__group.html#ga224870a424283b9fb51de47f16e5b5ff"></a><br/></td></tr>
<tr class="memitem:ga8a0a5a446c3cbbcd71b22eed64ca5d24"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga8a0a5a446c3cbbcd71b22eed64ca5d24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga8a0a5a446c3cbbcd71b22eed64ca5d24">multiply</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;b, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;c, bool a_is_transpose, bool b_is_transpose, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type alpha, typename <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;::value_type beta)</td></tr>
<tr class="memdesc:ga8a0a5a446c3cbbcd71b22eed64ca5d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列×行列の演算を行う  <a href="group__numeric__group.html#ga8a0a5a446c3cbbcd71b22eed64ca5d24"></a><br/></td></tr>
<tr class="memitem:ga22ee45733586d329e0cc04b136f993b2"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga22ee45733586d329e0cc04b136f993b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga22ee45733586d329e0cc04b136f993b2">multiply</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;b, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;c, bool a_is_transpose=false, bool b_is_transpose=false)</td></tr>
<tr class="memdesc:ga22ee45733586d329e0cc04b136f993b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列×行列の演算を行う  <a href="group__numeric__group.html#ga22ee45733586d329e0cc04b136f993b2"></a><br/></td></tr>
<tr class="memitem:gaf17f3062108a491ae28427bcacfffda9"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:gaf17f3062108a491ae28427bcacfffda9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#gaf17f3062108a491ae28427bcacfffda9">permutation_matrix</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T1, Allocator1 &gt; &amp;pivot, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T2, Allocator2 &gt; &amp;out)</td></tr>
<tr class="memdesc:gaf17f3062108a491ae28427bcacfffda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU分解などで得られるピボット配列からピボット行列を作成  <a href="group__numeric__group.html#gaf17f3062108a491ae28427bcacfffda9"></a><br/></td></tr>
<tr class="memitem:ga007686de5a5b2750f03f579e88efb2d3"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga007686de5a5b2750f03f579e88efb2d3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;<br class="typebreak"/>
::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga007686de5a5b2750f03f579e88efb2d3">trace</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a)</td></tr>
<tr class="memdesc:ga007686de5a5b2750f03f579e88efb2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">トレースの計算（対角成分の和）  <a href="group__numeric__group.html#ga007686de5a5b2750f03f579e88efb2d3"></a><br/></td></tr>
<tr class="memitem:ga4629afcc450bb6ad7ae8c2a387f28b50"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga4629afcc450bb6ad7ae8c2a387f28b50"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;<br class="typebreak"/>
::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga4629afcc450bb6ad7ae8c2a387f28b50">det</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga4629afcc450bb6ad7ae8c2a387f28b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列式の計算  <a href="group__numeric__group.html#ga4629afcc450bb6ad7ae8c2a387f28b50"></a><br/></td></tr>
<tr class="memitem:ga6709a4d9733dafcb5fab51c0a6811f98"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga6709a4d9733dafcb5fab51c0a6811f98"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga6709a4d9733dafcb5fab51c0a6811f98">solve</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;b, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga6709a4d9733dafcb5fab51c0a6811f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の連立一次方程式を解く関数  <a href="group__numeric__group.html#ga6709a4d9733dafcb5fab51c0a6811f98"></a><br/></td></tr>
<tr class="memitem:ga09d4ad5b46a612d36d046f7dee47b065"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga09d4ad5b46a612d36d046f7dee47b065"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga09d4ad5b46a612d36d046f7dee47b065">lu_factorization</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator1 &gt; &amp;a, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; __clapack__::integer, Allocator2 &gt; &amp;pivot, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga09d4ad5b46a612d36d046f7dee47b065"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列のLU分解を行う  <a href="group__numeric__group.html#ga09d4ad5b46a612d36d046f7dee47b065"></a><br/></td></tr>
<tr class="memitem:ga23643e8a2c7459bdc8821f97d1f5ac76"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga23643e8a2c7459bdc8821f97d1f5ac76"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga23643e8a2c7459bdc8821f97d1f5ac76">lu_factorization</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;L, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;U, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;pivot, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga23643e8a2c7459bdc8821f97d1f5ac76"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列のLU分解を行う  <a href="group__numeric__group.html#ga23643e8a2c7459bdc8821f97d1f5ac76"></a><br/></td></tr>
<tr class="memitem:ga39bb1130779dc9a8d06c1193ba242b3d"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga39bb1130779dc9a8d06c1193ba242b3d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga39bb1130779dc9a8d06c1193ba242b3d">lu_factorization</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga39bb1130779dc9a8d06c1193ba242b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列のLU分解を行う  <a href="group__numeric__group.html#ga39bb1130779dc9a8d06c1193ba242b3d"></a><br/></td></tr>
<tr class="memitem:ga93e574190cb6b2b799b080446bcc3d7b"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga93e574190cb6b2b799b080446bcc3d7b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga93e574190cb6b2b799b080446bcc3d7b">cholesky_factorization</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70ba150ed47f3977d0be8017e13c6216c307">matrix_style::sy</a>)</td></tr>
<tr class="memdesc:ga93e574190cb6b2b799b080446bcc3d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">対称行列のコレスキー分解を行う  <a href="group__numeric__group.html#ga93e574190cb6b2b799b080446bcc3d7b"></a><br/></td></tr>
<tr class="memitem:ga9f2c1f0b1c0105313749a4a08779f98e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga9f2c1f0b1c0105313749a4a08779f98e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga9f2c1f0b1c0105313749a4a08779f98e">qr_factorization</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;Q, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;R, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga9f2c1f0b1c0105313749a4a08779f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列のQR分解を行う  <a href="group__numeric__group.html#ga9f2c1f0b1c0105313749a4a08779f98e"></a><br/></td></tr>
<tr class="memitem:ga260dc839da68a5284bf1dabe2ede3cff"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga260dc839da68a5284bf1dabe2ede3cff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga260dc839da68a5284bf1dabe2ede3cff">inverse</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga260dc839da68a5284bf1dabe2ede3cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の逆行列をLU分解を用いて計算する  <a href="group__numeric__group.html#ga260dc839da68a5284bf1dabe2ede3cff"></a><br/></td></tr>
<tr class="memitem:ga94da1e1c8dd4fdcac80077d86a8b417e"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga94da1e1c8dd4fdcac80077d86a8b417e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga94da1e1c8dd4fdcac80077d86a8b417e">eigen</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;a, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;eigen_value, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; &amp;eigen_vector, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga94da1e1c8dd4fdcac80077d86a8b417e"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の固有値・固有ベクトルを計算する  <a href="group__numeric__group.html#ga94da1e1c8dd4fdcac80077d86a8b417e"></a><br/></td></tr>
<tr class="memitem:ga5f85b437b93dc620f245de814b76ba45"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga5f85b437b93dc620f245de814b76ba45"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T2, Allocator2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga5f85b437b93dc620f245de814b76ba45">svd</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T1, Allocator1 &gt; &amp;a, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T1, Allocator1 &gt; &amp;u, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T2, Allocator2 &gt; &amp;s, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T1, Allocator1 &gt; &amp;vt, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga5f85b437b93dc620f245de814b76ba45"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の特異値分解を計算する  <a href="group__numeric__group.html#ga5f85b437b93dc620f245de814b76ba45"></a><br/></td></tr>
<tr class="memitem:ga79b15340c2aceca0d19497522c616722"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class Allocator1 , class Allocator2 &gt; </td></tr>
<tr class="memitem:ga79b15340c2aceca0d19497522c616722"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T2, Allocator2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric__group.html#ga79b15340c2aceca0d19497522c616722">svd</a> (const <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T1, Allocator1 &gt; &amp;a, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T2, Allocator2 &gt; &amp;s, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T1, Allocator1 &gt; &amp;vt, <a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70b">matrix_style::style</a> style=<a class="el" href="structmist_1_1matrix__style.html#a0761663cc42310d1c0040bcb5071e70baab0e4966f9166f3fc799996b82634766">matrix_style::ge</a>)</td></tr>
<tr class="memdesc:ga79b15340c2aceca0d19497522c616722"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の特異値分解を計算する  <a href="group__numeric__group.html#ga79b15340c2aceca0d19497522c616722"></a><br/></td></tr>
<tr class="memitem:ga0d5b20b4c80c94163ac99f45f0e47270"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 &gt; </td></tr>
<tr class="memitem:ga0d5b20b4c80c94163ac99f45f0e47270"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__poisson__image__editing__group.html#ga0d5b20b4c80c94163ac99f45f0e47270">seamlessCloning</a> (const Array1 &amp;src, const Array2 &amp;target, Array3 &amp;out, const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; unsigned char &gt; &amp;mask, const int offx=0, const int offy=0, const bool mix=false)</td></tr>
<tr class="memdesc:ga0d5b20b4c80c94163ac99f45f0e47270"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力画像のマスク領域を対象画像に合成する  <a href="group__poisson__image__editing__group.html#ga0d5b20b4c80c94163ac99f45f0e47270"></a><br/></td></tr>
<tr class="memitem:ga7963adebf9c927aef96fe10bc079a2d9"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga7963adebf9c927aef96fe10bc079a2d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__poisson__image__editing__group.html#ga7963adebf9c927aef96fe10bc079a2d9">localColorChange</a> (const Array1 &amp;in, Array2 &amp;out, const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; unsigned char &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga7963adebf9c927aef96fe10bc079a2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力画像のマスク領域以外をグレースケールにする  <a href="group__poisson__image__editing__group.html#ga7963adebf9c927aef96fe10bc079a2d9"></a><br/></td></tr>
<tr class="memitem:ga20e213d2e6290329fa582d167b53b41f"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:ga20e213d2e6290329fa582d167b53b41f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__poisson__image__editing__group.html#ga20e213d2e6290329fa582d167b53b41f">localColorChange</a> (const Array1 &amp;in, Array2 &amp;out, const <a class="el" href="classmist_1_1array2.html">array2</a>&lt; unsigned char &gt; &amp;mask, const <a class="el" href="structmist_1_1rgb.html">rgb</a>&lt; double &gt; multiplier)</td></tr>
<tr class="memdesc:ga20e213d2e6290329fa582d167b53b41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">入力画像のマスク領域だけ色成分を変更する  <a href="group__poisson__image__editing__group.html#ga20e213d2e6290329fa582d167b53b41f"></a><br/></td></tr>
<tr class="memitem:a1c6f361cc4ffaf3848f4dec810ab27ff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1c6f361cc4ffaf3848f4dec810ab27ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a1c6f361cc4ffaf3848f4dec810ab27ff">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt; &amp;q)</td></tr>
<tr class="memdesc:a1c6f361cc4ffaf3848f4dec810ab27ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">クォータニオンの和  <a href="#a1c6f361cc4ffaf3848f4dec810ab27ff"></a><br/></td></tr>
<tr class="memitem:a416c4e90fbe4e1ecb13ea585d80a77b2"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a416c4e90fbe4e1ecb13ea585d80a77b2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a416c4e90fbe4e1ecb13ea585d80a77b2">interpolate</a> (const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T1 &gt; &amp;q1, const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T2 &gt; &amp;q2, double t)</td></tr>
<tr class="memdesc:a416c4e90fbe4e1ecb13ea585d80a77b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">球面線形補間を行う  <a href="#a416c4e90fbe4e1ecb13ea585d80a77b2"></a><br/></td></tr>
<tr class="memitem:a729e367dc6a47602a4bdee4635ead73c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a729e367dc6a47602a4bdee4635ead73c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a729e367dc6a47602a4bdee4635ead73c">track_ball</a> (const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T &gt; &amp;p1, const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T &gt; &amp;p2, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisX, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; axisY, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; axisZ, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;trackball_size)</td></tr>
<tr class="memdesc:a729e367dc6a47602a4bdee4635ead73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想トラックボールの実装(左手座標系)  <a href="#a729e367dc6a47602a4bdee4635ead73c"></a><br/></td></tr>
<tr class="memitem:a68bb87edf3accc81e8b5ed12dfbdd717"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a68bb87edf3accc81e8b5ed12dfbdd717"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a68bb87edf3accc81e8b5ed12dfbdd717">track_ball</a> (const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T &gt; &amp;p1, const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T &gt; &amp;p2, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisX, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; axisY, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; axisZ)</td></tr>
<tr class="memdesc:a68bb87edf3accc81e8b5ed12dfbdd717"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想トラックボールの実装(左手座標系)  <a href="#a68bb87edf3accc81e8b5ed12dfbdd717"></a><br/></td></tr>
<tr class="memitem:a346202ee02abebad2f521b4bc4e8dd54"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a346202ee02abebad2f521b4bc4e8dd54"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a346202ee02abebad2f521b4bc4e8dd54">track_ball</a> (const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;x1, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;y1, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;x2, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;y2, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisX, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisY, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisZ, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;trackball_size)</td></tr>
<tr class="memdesc:a346202ee02abebad2f521b4bc4e8dd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想トラックボールの実装(左手座標系)  <a href="#a346202ee02abebad2f521b4bc4e8dd54"></a><br/></td></tr>
<tr class="memitem:ae7784dceff9f4ce63b4ebad61470eb3e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae7784dceff9f4ce63b4ebad61470eb3e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ae7784dceff9f4ce63b4ebad61470eb3e">track_ball</a> (const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;x1, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;y1, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;x2, const typename <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt;::value_type &amp;y2, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisX, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisY, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;axisZ)</td></tr>
<tr class="memdesc:ae7784dceff9f4ce63b4ebad61470eb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想トラックボールの実装(左手座標系)  <a href="#ae7784dceff9f4ce63b4ebad61470eb3e"></a><br/></td></tr>
<tr class="memitem:ab9fb1569d902b877a7ad34c8ff42d650"><td class="memTemplParams" colspan="2">template&lt;int M, typename V , typename A &gt; </td></tr>
<tr class="memitem:ab9fb1569d902b877a7ad34c8ff42d650"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ab9fb1569d902b877a7ad34c8ff42d650">operator+</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t1, const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t2)</td></tr>
<tr class="memdesc:ab9fb1569d902b877a7ad34c8ff42d650"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition operator to calculate summation of two tensors  <a href="#ab9fb1569d902b877a7ad34c8ff42d650"></a><br/></td></tr>
<tr class="memitem:a37610ff35a42dc00727926aa2422603c"><td class="memTemplParams" colspan="2">template&lt;int M, typename V , typename A &gt; </td></tr>
<tr class="memitem:a37610ff35a42dc00727926aa2422603c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a37610ff35a42dc00727926aa2422603c">operator-</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t1, const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t2)</td></tr>
<tr class="memdesc:a37610ff35a42dc00727926aa2422603c"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtraction operator to calculate difference betwwen two tensors  <a href="#a37610ff35a42dc00727926aa2422603c"></a><br/></td></tr>
<tr class="memitem:ada03b8c07dc2afd518e2195778b69843"><td class="memTemplParams" colspan="2">template&lt;int M, typename V , typename A &gt; </td></tr>
<tr class="memitem:ada03b8c07dc2afd518e2195778b69843"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ada03b8c07dc2afd518e2195778b69843">operator*</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t, const typename <a class="el" href="structmist_1_1type__trait.html">type_trait</a>&lt; V &gt;::value_type &amp;v)</td></tr>
<tr class="memdesc:ada03b8c07dc2afd518e2195778b69843"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication operator to calculate product of a tensor and a value  <a href="#ada03b8c07dc2afd518e2195778b69843"></a><br/></td></tr>
<tr class="memitem:a694eede7a367296762843fd1a6d6c213"><td class="memTemplParams" colspan="2">template&lt;int M, typename V , typename A &gt; </td></tr>
<tr class="memitem:a694eede7a367296762843fd1a6d6c213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a694eede7a367296762843fd1a6d6c213">operator*</a> (const typename <a class="el" href="structmist_1_1type__trait.html">type_trait</a>&lt; V &gt;::value_type &amp;v, const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t)</td></tr>
<tr class="memdesc:a694eede7a367296762843fd1a6d6c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication operator to calculate product of a value and a tensor  <a href="#a694eede7a367296762843fd1a6d6c213"></a><br/></td></tr>
<tr class="memitem:ae76e32fb5ed29261feca6558fed16642"><td class="memTemplParams" colspan="2">template&lt;int M, typename V , typename A &gt; </td></tr>
<tr class="memitem:ae76e32fb5ed29261feca6558fed16642"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#ae76e32fb5ed29261feca6558fed16642">operator/</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t, const typename <a class="el" href="structmist_1_1type__trait.html">type_trait</a>&lt; V &gt;::value_type &amp;v)</td></tr>
<tr class="memdesc:ae76e32fb5ed29261feca6558fed16642"><td class="mdescLeft">&#160;</td><td class="mdescRight">division operator to calculate quotient of a tensor and a value  <a href="#ae76e32fb5ed29261feca6558fed16642"></a><br/></td></tr>
<tr class="memitem:abc313580631612db62b33ba97db28e82"><td class="memTemplParams" colspan="2">template&lt;int M, typename V , typename A &gt; </td></tr>
<tr class="memitem:abc313580631612db62b33ba97db28e82"><td class="memTemplItemLeft" align="right" valign="top">inline::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#abc313580631612db62b33ba97db28e82">operator&lt;&lt;</a> (::std::ostream &amp;o, const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; &amp;t)</td></tr>
<tr class="memdesc:abc313580631612db62b33ba97db28e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream operator  <a href="#abc313580631612db62b33ba97db28e82"></a><br/></td></tr>
<tr class="memitem:afeb4393ea1a69bfbabde03b68dace5c6"><td class="memTemplParams" colspan="2">template&lt;typename TV , typename TA , typename MV , typename MA &gt; </td></tr>
<tr class="memitem:afeb4393ea1a69bfbabde03b68dace5c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#afeb4393ea1a69bfbabde03b68dace5c6">hosvd</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 2, TV, TA &gt; &amp;t, <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 2, TV, TA &gt; &amp;z, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u1, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u2)</td></tr>
<tr class="memdesc:afeb4393ea1a69bfbabde03b68dace5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply higher order singular value decomposition (HOSVD) to a 2nd order tensor  <a href="#afeb4393ea1a69bfbabde03b68dace5c6"></a><br/></td></tr>
<tr class="memitem:a2264c6a7020ead7e633ab9d993414be3"><td class="memTemplParams" colspan="2">template&lt;typename TV , typename TA , typename MV , typename MA &gt; </td></tr>
<tr class="memitem:a2264c6a7020ead7e633ab9d993414be3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a2264c6a7020ead7e633ab9d993414be3">hosvd</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 3, TV, TA &gt; &amp;t, <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 3, TV, TA &gt; &amp;z, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u1, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u2, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u3)</td></tr>
<tr class="memdesc:a2264c6a7020ead7e633ab9d993414be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply higher order singular value decomposition (HOSVD) to a 3rd order tensor  <a href="#a2264c6a7020ead7e633ab9d993414be3"></a><br/></td></tr>
<tr class="memitem:a84544efc033853ec645e806f2c61cc14"><td class="memTemplParams" colspan="2">template&lt;typename TV , typename TA , typename MV , typename MA &gt; </td></tr>
<tr class="memitem:a84544efc033853ec645e806f2c61cc14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a84544efc033853ec645e806f2c61cc14">hosvd</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 4, TV, TA &gt; &amp;t, <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 4, TV, TA &gt; &amp;z, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u1, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u2, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u3, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u4)</td></tr>
<tr class="memdesc:a84544efc033853ec645e806f2c61cc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply higher order singular value decomposition (HOSVD) to a 4th order tensor  <a href="#a84544efc033853ec645e806f2c61cc14"></a><br/></td></tr>
<tr class="memitem:a42b408762e7f1956b79d9bf683d85a03"><td class="memTemplParams" colspan="2">template&lt;typename TV , typename TA , typename MV , typename MA &gt; </td></tr>
<tr class="memitem:a42b408762e7f1956b79d9bf683d85a03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemist.html#a42b408762e7f1956b79d9bf683d85a03">hosvd</a> (const <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 5, TV, TA &gt; &amp;t, <a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; 5, TV, TA &gt; &amp;z, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u1, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u2, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u3, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u4, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; MV, MA &gt; &amp;u5)</td></tr>
<tr class="memdesc:a42b408762e7f1956b79d9bf683d85a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply higher order singular value decomposition (HOSVD) to a 5th order tensor  <a href="#a42b408762e7f1956b79d9bf683d85a03"></a><br/></td></tr>
<tr class="memitem:gadef82157796ad103bfc943dba8ef17e6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__group.html#gadef82157796ad103bfc943dba8ef17e6">get_cpu_num</a> ()</td></tr>
<tr class="memdesc:gadef82157796ad103bfc943dba8ef17e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">利用可能なCPU数を取得する  <a href="group__thread__group.html#gadef82157796ad103bfc943dba8ef17e6"></a><br/></td></tr>
<tr class="memitem:ga969bde1c76b4f3cd6811fa709dd7b7e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga969bde1c76b4f3cd6811fa709dd7b7e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga969bde1c76b4f3cd6811fa709dd7b7e5">sleep</a> (size_t dwMilliseconds)</td></tr>
<tr class="memdesc:ga969bde1c76b4f3cd6811fa709dd7b7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定した時間だけスリープする（ミリ秒単位） <br/></td></tr>
<tr class="memitem:ga0f635b9fa0dc3d181f41fa4830a18513"><td class="memTemplParams" colspan="2">template&lt;class Thread &gt; </td></tr>
<tr class="memitem:ga0f635b9fa0dc3d181f41fa4830a18513"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga0f635b9fa0dc3d181f41fa4830a18513">do_threads_</a> (Thread *threads, size_t num_threads, unsigned long dwMilliseconds=INFINITE)</td></tr>
<tr class="memdesc:ga0f635b9fa0dc3d181f41fa4830a18513"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド生成・終了待機・スレッドの破棄までを一連の流れとして行う  <a href="group__thread__group.html#ga0f635b9fa0dc3d181f41fa4830a18513"></a><br/></td></tr>
<tr class="memitem:ga928b8291ead96a17557ccc1b47eb858b"><td class="memTemplParams" colspan="2">template&lt;class Thread &gt; </td></tr>
<tr class="memitem:ga928b8291ead96a17557ccc1b47eb858b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga928b8291ead96a17557ccc1b47eb858b">do_threads_</a> (Thread **threads, size_t num_threads, unsigned long dwMilliseconds=INFINITE)</td></tr>
<tr class="memdesc:ga928b8291ead96a17557ccc1b47eb858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド生成・終了待機・スレッドの破棄までを一連の流れとして行う  <a href="group__thread__group.html#ga928b8291ead96a17557ccc1b47eb858b"></a><br/></td></tr>
<tr class="memitem:ga8a2ddfc1cc10d1c045cea4005cb39cdf"><td class="memTemplParams" colspan="2">template&lt;class Thread &gt; </td></tr>
<tr class="memitem:ga8a2ddfc1cc10d1c045cea4005cb39cdf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga8a2ddfc1cc10d1c045cea4005cb39cdf">do_threads</a> (Thread *threads, size_t num_threads, unsigned long dwMilliseconds=INFINITE)</td></tr>
<tr class="memdesc:ga8a2ddfc1cc10d1c045cea4005cb39cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド生成・終了待機・スレッドの破棄までを一連の流れとして行う  <a href="group__thread__group.html#ga8a2ddfc1cc10d1c045cea4005cb39cdf"></a><br/></td></tr>
<tr class="memitem:gafeb86244422915e0de6c7590e1234a2e"><td class="memTemplParams" colspan="2">template&lt;class Param , class Functor &gt; </td></tr>
<tr class="memitem:gafeb86244422915e0de6c7590e1234a2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1thread__handle.html">thread_handle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__thread__group.html#gafeb86244422915e0de6c7590e1234a2e">create_thread</a> (Param &amp;param, Functor f)</td></tr>
<tr class="memdesc:gafeb86244422915e0de6c7590e1234a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したスレッド関数を利用する，スレッドを作成する  <a href="group__thread__group.html#gafeb86244422915e0de6c7590e1234a2e"></a><br/></td></tr>
<tr class="memitem:ga91b970d43d849a4601bf8ca51b48e936"><td class="memTemplParams" colspan="2">template&lt;class Param , class Functor &gt; </td></tr>
<tr class="memitem:ga91b970d43d849a4601bf8ca51b48e936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga91b970d43d849a4601bf8ca51b48e936">create_threads</a> (<a class="el" href="classmist_1_1thread__handle.html">thread_handle</a> *handles, Param *param, size_t num_threads, Functor f)</td></tr>
<tr class="memdesc:ga91b970d43d849a4601bf8ca51b48e936"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したスレッド関数を利用する，スレッドを複数作成する  <a href="group__thread__group.html#ga91b970d43d849a4601bf8ca51b48e936"></a><br/></td></tr>
<tr class="memitem:ga3b135ecb8667be3b833276de8e917c70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga3b135ecb8667be3b833276de8e917c70">close_thread</a> (<a class="el" href="classmist_1_1thread__handle.html">thread_handle</a> &amp;thread_)</td></tr>
<tr class="memdesc:ga3b135ecb8667be3b833276de8e917c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドが使用していたリソースを開放する  <a href="group__thread__group.html#ga3b135ecb8667be3b833276de8e917c70"></a><br/></td></tr>
<tr class="memitem:gae2fab43a6c76df8b610e8e0e02f1c741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__group.html#gae2fab43a6c76df8b610e8e0e02f1c741">close_threads</a> (<a class="el" href="classmist_1_1thread__handle.html">thread_handle</a> *handles, size_t num_threads)</td></tr>
<tr class="memdesc:gae2fab43a6c76df8b610e8e0e02f1c741"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数のスレッドが使用していたリソースを開放する  <a href="group__thread__group.html#gae2fab43a6c76df8b610e8e0e02f1c741"></a><br/></td></tr>
<tr class="memitem:ga15b1f1c5d9e6494e6aca9071050a2ca7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga15b1f1c5d9e6494e6aca9071050a2ca7">wait_thread</a> (<a class="el" href="classmist_1_1thread__handle.html">thread_handle</a> &amp;thread_, unsigned long dwMilliseconds=INFINITE)</td></tr>
<tr class="memdesc:ga15b1f1c5d9e6494e6aca9071050a2ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドが終了するか，タイムアウトが発生するまで待機する  <a href="group__thread__group.html#ga15b1f1c5d9e6494e6aca9071050a2ca7"></a><br/></td></tr>
<tr class="memitem:gaa3852e271bf7bde41c25c236036b047f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__thread__group.html#gaa3852e271bf7bde41c25c236036b047f">wait_threads</a> (<a class="el" href="classmist_1_1thread__handle.html">thread_handle</a> *handles, size_t num_threads, unsigned long dwMilliseconds=INFINITE)</td></tr>
<tr class="memdesc:gaa3852e271bf7bde41c25c236036b047f"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数のスレッドが使用していたリソースを開放する  <a href="group__thread__group.html#gaa3852e271bf7bde41c25c236036b047f"></a><br/></td></tr>
<tr class="memitem:ga07d201d0b1a6135e0f47fa2569be33f3"><td class="memTemplParams" colspan="2">template&lt;class Param , class Functor &gt; </td></tr>
<tr class="memitem:ga07d201d0b1a6135e0f47fa2569be33f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga07d201d0b1a6135e0f47fa2569be33f3">do_thread</a> (Param &amp;param, Functor f, unsigned long dwMilliseconds=INFINITE)</td></tr>
<tr class="memdesc:ga07d201d0b1a6135e0f47fa2569be33f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド生成・終了待機・スレッドの破棄までを一連の流れとして行う  <a href="group__thread__group.html#ga07d201d0b1a6135e0f47fa2569be33f3"></a><br/></td></tr>
<tr class="memitem:ga50ae7daac1beec2082919b1374dc39d1"><td class="memTemplParams" colspan="2">template&lt;class Param , class Functor &gt; </td></tr>
<tr class="memitem:ga50ae7daac1beec2082919b1374dc39d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__thread__group.html#ga50ae7daac1beec2082919b1374dc39d1">do_threads</a> (Param *params, size_t num_threads, Functor f, unsigned long dwMilliseconds=INFINITE)</td></tr>
<tr class="memdesc:ga50ae7daac1beec2082919b1374dc39d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド生成・終了待機・スレッドの破棄までを一連の流れとして行う  <a href="group__thread__group.html#ga50ae7daac1beec2082919b1374dc39d1"></a><br/></td></tr>
<tr class="memitem:a5942791f8f865a86f65267109d54aab0"><td class="memItemLeft" align="right" valign="top">inline::std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a5942791f8f865a86f65267109d54aab0">operator&lt;&lt;</a> (::std::ostream &amp;out, const <a class="el" href="classmist_1_1timer.html">timer</a> &amp;t)</td></tr>
<tr class="memdesc:a5942791f8f865a86f65267109d54aab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">経過時間を標準出力に出力する．  <a href="#a5942791f8f865a86f65267109d54aab0"></a><br/></td></tr>
<tr class="memitem:a79d8f91cb3624875a3b23c60c4da932d"><td class="memItemLeft" align="right" valign="top">inline::std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemist.html#a79d8f91cb3624875a3b23c60c4da932d">operator&lt;&lt;</a> (::std::ostream &amp;out, const <a class="el" href="classmist_1_1stopwatch.html">stopwatch</a> &amp;t)</td></tr>
<tr class="memdesc:a79d8f91cb3624875a3b23c60c4da932d"><td class="mdescLeft">&#160;</td><td class="mdescRight">経過時間を標準出力に出力する．  <a href="#a79d8f91cb3624875a3b23c60c4da932d"></a><br/></td></tr>
<tr class="memitem:gaa7fba9115e365e00594305a36154242f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__balloon__group.html#gaa7fba9115e365e00594305a36154242f">balloon</a> (size_t number_of_division)</td></tr>
<tr class="memdesc:gaa7fba9115e365e00594305a36154242f"><td class="mdescLeft">&#160;</td><td class="mdescRight">正20面体を分割して，球面上の方向集合を取得する  <a href="group__balloon__group.html#gaa7fba9115e365e00594305a36154242f"></a><br/></td></tr>
<tr class="memitem:ga307d49989643c047c051396d2f0a0443"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__balloon__group.html#ga307d49989643c047c051396d2f0a0443">half_balloon</a> (size_t number_of_division)</td></tr>
<tr class="memdesc:ga307d49989643c047c051396d2f0a0443"><td class="mdescLeft">&#160;</td><td class="mdescRight">正20面体を分割して，球面上の方向集合を取得する  <a href="group__balloon__group.html#ga307d49989643c047c051396d2f0a0443"></a><br/></td></tr>
<tr class="memitem:ga9021ed72e0c82f21383cb13c8bbe92e5"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga9021ed72e0c82f21383cb13c8bbe92e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mesh__group.html#ga9021ed72e0c82f21383cb13c8bbe92e5">extract_mesh</a> (<a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt; &amp;chart, <a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; double &gt; &gt; &amp;grid, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type row, typename <a class="el" href="classmist_1_1array2.html">array2</a>&lt; T, Allocator &gt;::difference_type col, double threshold_for_circular_ratio=0.4)</td></tr>
<tr class="memdesc:ga9021ed72e0c82f21383cb13c8bbe92e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">円を格子状に並べた画像から，各点を抽出しメッシュ上の点と対応付ける  <a href="group__mesh__group.html#ga9021ed72e0c82f21383cb13c8bbe92e5"></a><br/></td></tr>
<tr class="memitem:ga5cb42b1fe86f96fe5afec693254130d6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5cb42b1fe86f96fe5afec693254130d6"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga5cb42b1fe86f96fe5afec693254130d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmist_1_1promote__trait.html">promote_trait</a>&lt; T1, T2 &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#ga5cb42b1fe86f96fe5afec693254130d6">operator^</a> (const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ga5cb42b1fe86f96fe5afec693254130d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの内積 <br/></td></tr>
<tr class="memitem:ga5ac511970cdc73f129818029b07d5af3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5ac511970cdc73f129818029b07d5af3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#ga5ac511970cdc73f129818029b07d5af3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga5ac511970cdc73f129818029b07d5af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの和  <a href="group__vector__group.html#ga5ac511970cdc73f129818029b07d5af3"></a><br/></td></tr>
<tr class="memitem:ga64c1cf179a134ea54d8afd175dab5899"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga64c1cf179a134ea54d8afd175dab5899"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#ga64c1cf179a134ea54d8afd175dab5899">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classmist_1_1vector3.html">vector3</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga64c1cf179a134ea54d8afd175dab5899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for reading the vector comma separated from an istream.  <a href="group__vector__group.html#ga64c1cf179a134ea54d8afd175dab5899"></a><br/></td></tr>
<tr class="memitem:gab997a41399c670c02c7a55e55ed067f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab997a41399c670c02c7a55e55ed067f1"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:gab997a41399c670c02c7a55e55ed067f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmist_1_1promote__trait.html">promote_trait</a>&lt; T1, T2 &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#gab997a41399c670c02c7a55e55ed067f1">operator^</a> (const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:gab997a41399c670c02c7a55e55ed067f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの内積 <br/></td></tr>
<tr class="memitem:ga5e07456373d42e1d55a1ed29a0573b6c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5e07456373d42e1d55a1ed29a0573b6c"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga5e07456373d42e1d55a1ed29a0573b6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmist_1_1promote__trait.html">promote_trait</a>&lt; T1, T2 &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#ga5e07456373d42e1d55a1ed29a0573b6c">operator*</a> (const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T1 &gt; &amp;v1, const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ga5e07456373d42e1d55a1ed29a0573b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの外積 <br/></td></tr>
<tr class="memitem:gade7455e6af38c3b818bc881175de483c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gade7455e6af38c3b818bc881175de483c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#gade7455e6af38c3b818bc881175de483c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gade7455e6af38c3b818bc881175de483c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの和  <a href="group__vector__group.html#gade7455e6af38c3b818bc881175de483c"></a><br/></td></tr>
<tr class="memitem:gab6a30af4e9854194efb9a375b98651a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab6a30af4e9854194efb9a375b98651a4"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#gab6a30af4e9854194efb9a375b98651a4">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classmist_1_1vector2.html">vector2</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gab6a30af4e9854194efb9a375b98651a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for reading the vector comma separated from an istream.  <a href="group__vector__group.html#gab6a30af4e9854194efb9a375b98651a4"></a><br/></td></tr>
<tr class="memitem:ga945db0002bc912fad0737acf80668f78"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga945db0002bc912fad0737acf80668f78"><td class="memTemplItemLeft" align="right" valign="top">inline::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#ga945db0002bc912fad0737acf80668f78">operator&lt;&lt;</a> (::std::ostream &amp;out, const <a class="el" href="classmist_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;v)</td></tr>
<tr class="memdesc:ga945db0002bc912fad0737acf80668f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたストリームに，行列内の要素を整形して出力する  <a href="group__vector__group.html#ga945db0002bc912fad0737acf80668f78"></a><br/></td></tr>
<tr class="memitem:ga5f0379e2d10870ca96ab94145f5918ed"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ga5f0379e2d10870ca96ab94145f5918ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector.html">vector</a>&lt; T, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__group.html#ga5f0379e2d10870ca96ab94145f5918ed">operator*</a> (const <a class="el" href="classmist_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;v1, const <a class="el" href="classmist_1_1vector.html">vector</a>&lt; T, Allocator &gt; &amp;v2)</td></tr>
<tr class="memdesc:ga5f0379e2d10870ca96ab94145f5918ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの外積を計算する  <a href="group__vector__group.html#ga5f0379e2d10870ca96ab94145f5918ed"></a><br/></td></tr>
<tr class="memitem:ga387d2cf52eb6e643c67922cd8cb140af"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class DepthMap , class Renderer , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:ga387d2cf52eb6e643c67922cd8cb140af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga387d2cf52eb6e643c67922cd8cb140af">volumerendering</a> (const Array1 &amp;in, Array2 &amp;out, const DepthMap &amp;dmap, const Renderer &amp;renderer, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga387d2cf52eb6e643c67922cd8cb140af"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#ga387d2cf52eb6e643c67922cd8cb140af"></a><br/></td></tr>
<tr class="memitem:gad30ee1b1467c691baf046be283ec1131"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class DepthMap , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:gad30ee1b1467c691baf046be283ec1131"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#gad30ee1b1467c691baf046be283ec1131">volumerendering</a> (const Array1 &amp;in, Array2 &amp;out, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:gad30ee1b1467c691baf046be283ec1131"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#gad30ee1b1467c691baf046be283ec1131"></a><br/></td></tr>
<tr class="memitem:ga98627684493fad722934493f08c15151"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:ga98627684493fad722934493f08c15151"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga98627684493fad722934493f08c15151">volumerendering</a> (const Array1 &amp;in, Array2 &amp;out, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga98627684493fad722934493f08c15151"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#ga98627684493fad722934493f08c15151"></a><br/></td></tr>
<tr class="memitem:gac93c909a847d48ef118f94d16dd558a5"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class DepthMap , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:gac93c909a847d48ef118f94d16dd558a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#gac93c909a847d48ef118f94d16dd558a5">volumerendering</a> (const Array1 &amp;in, const Array2 &amp;mk, Array3 &amp;out, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;mktable, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:gac93c909a847d48ef118f94d16dd558a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#gac93c909a847d48ef118f94d16dd558a5"></a><br/></td></tr>
<tr class="memitem:ga8f6b82487a2b7170586fcf15c0e3ab46"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class DepthMap , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:ga8f6b82487a2b7170586fcf15c0e3ab46"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga8f6b82487a2b7170586fcf15c0e3ab46">volumerendering</a> (const Array1 &amp;in, const Array2 &amp;mk, Array3 &amp;out, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;mktable, bool apply_and_operation, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga8f6b82487a2b7170586fcf15c0e3ab46"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#ga8f6b82487a2b7170586fcf15c0e3ab46"></a><br/></td></tr>
<tr class="memitem:ga908319422c01e006444115278f3f2a43"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:ga908319422c01e006444115278f3f2a43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga908319422c01e006444115278f3f2a43">volumerendering</a> (const Array1 &amp;in, const Array2 &amp;mk, Array3 &amp;out, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;mktable, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga908319422c01e006444115278f3f2a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#ga908319422c01e006444115278f3f2a43"></a><br/></td></tr>
<tr class="memitem:ga6f2e0ac1301a6e398b90454c04234c2b"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:ga6f2e0ac1301a6e398b90454c04234c2b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga6f2e0ac1301a6e398b90454c04234c2b">volumerendering</a> (const Array1 &amp;in, const Array2 &amp;mk, Array3 &amp;out, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;mktable, bool apply_and_operation, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga6f2e0ac1301a6e398b90454c04234c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#ga6f2e0ac1301a6e398b90454c04234c2b"></a><br/></td></tr>
<tr class="memitem:gaf8030793cad706695326d2b7da38e3b6"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 &gt; </td></tr>
<tr class="memitem:gaf8030793cad706695326d2b7da38e3b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#gaf8030793cad706695326d2b7da38e3b6">mip</a> (const Array1 &amp;in, Array2 &amp;out, const volumerender::parameter &amp;p, typename Array1::size_type thread_num=0)</td></tr>
<tr class="memdesc:gaf8030793cad706695326d2b7da38e3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#gaf8030793cad706695326d2b7da38e3b6"></a><br/></td></tr>
<tr class="memitem:ga8899fdcc774f3b872ef75ccebbe0029e"><td class="memTemplParams" colspan="2">template&lt;class Array , class DepthMap , class Renderer , class T &gt; </td></tr>
<tr class="memitem:ga8899fdcc774f3b872ef75ccebbe0029e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga8899fdcc774f3b872ef75ccebbe0029e">collision_detection</a> (const Array &amp;in, typename Array::size_type image_width, typename Array::size_type image_height, double resoX, double resoY, const DepthMap &amp;dmap, const Renderer &amp;renderer, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, typename Array::size_type i, typename Array::size_type j)</td></tr>
<tr class="memdesc:ga8899fdcc774f3b872ef75ccebbe0029e"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga8899fdcc774f3b872ef75ccebbe0029e"></a><br/></td></tr>
<tr class="memitem:ga04c30b4984f565dfbd97a843e030c04f"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class DepthMap , class Renderer , class T &gt; </td></tr>
<tr class="memitem:ga04c30b4984f565dfbd97a843e030c04f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga04c30b4984f565dfbd97a843e030c04f">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;out, const DepthMap &amp;dmap, const Renderer &amp;renderer, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga04c30b4984f565dfbd97a843e030c04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga04c30b4984f565dfbd97a843e030c04f"></a><br/></td></tr>
<tr class="memitem:ga35f90084e125ab5f125259135941c556"><td class="memTemplParams" colspan="2">template&lt;class Array , class DepthMap , class T &gt; </td></tr>
<tr class="memitem:ga35f90084e125ab5f125259135941c556"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga35f90084e125ab5f125259135941c556">collision_detection</a> (const Array &amp;in, typename Array::size_type image_width, typename Array::size_type image_height, double resoX, double resoY, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, typename Array::size_type i, typename Array::size_type j)</td></tr>
<tr class="memdesc:ga35f90084e125ab5f125259135941c556"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga35f90084e125ab5f125259135941c556"></a><br/></td></tr>
<tr class="memitem:ga1271ed378b9ea73b35bcc002918fecbd"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class DepthMap , class T &gt; </td></tr>
<tr class="memitem:ga1271ed378b9ea73b35bcc002918fecbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga1271ed378b9ea73b35bcc002918fecbd">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;out, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga1271ed378b9ea73b35bcc002918fecbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga1271ed378b9ea73b35bcc002918fecbd"></a><br/></td></tr>
<tr class="memitem:ga2e7a4adff43731a08b4f93624721af97"><td class="memTemplParams" colspan="2">template&lt;class Array , class T &gt; </td></tr>
<tr class="memitem:ga2e7a4adff43731a08b4f93624721af97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga2e7a4adff43731a08b4f93624721af97">collision_detection</a> (const Array &amp;in, typename Array::size_type image_width, typename Array::size_type image_height, double resoX, double resoY, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, typename Array::size_type i, typename Array::size_type j)</td></tr>
<tr class="memdesc:ga2e7a4adff43731a08b4f93624721af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga2e7a4adff43731a08b4f93624721af97"></a><br/></td></tr>
<tr class="memitem:ga117ffe0426ecfb4de26d69f94935bef0"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class T &gt; </td></tr>
<tr class="memitem:ga117ffe0426ecfb4de26d69f94935bef0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga117ffe0426ecfb4de26d69f94935bef0">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;out, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga117ffe0426ecfb4de26d69f94935bef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga117ffe0426ecfb4de26d69f94935bef0"></a><br/></td></tr>
<tr class="memitem:ga7b77eb71d2d1978a0e69377b75abd2dc"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class DepthMap , class T &gt; </td></tr>
<tr class="memitem:ga7b77eb71d2d1978a0e69377b75abd2dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga7b77eb71d2d1978a0e69377b75abd2dc">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, typename Array1::size_type image_width, typename Array1::size_type image_height, double resoX, double resoY, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga7b77eb71d2d1978a0e69377b75abd2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga7b77eb71d2d1978a0e69377b75abd2dc"></a><br/></td></tr>
<tr class="memitem:gaef39e6863b1fb86ae94437d03ff576a5"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class DepthMap , class T &gt; </td></tr>
<tr class="memitem:gaef39e6863b1fb86ae94437d03ff576a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#gaef39e6863b1fb86ae94437d03ff576a5">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, const Array3 &amp;out, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:gaef39e6863b1fb86ae94437d03ff576a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#gaef39e6863b1fb86ae94437d03ff576a5"></a><br/></td></tr>
<tr class="memitem:ga4bd15bbf9a93dca74573b8c4b3d42b01"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class DepthMap , class T &gt; </td></tr>
<tr class="memitem:ga4bd15bbf9a93dca74573b8c4b3d42b01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga4bd15bbf9a93dca74573b8c4b3d42b01">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, typename Array1::size_type image_width, typename Array1::size_type image_height, double resoX, double resoY, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, bool apply_and_operation, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga4bd15bbf9a93dca74573b8c4b3d42b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga4bd15bbf9a93dca74573b8c4b3d42b01"></a><br/></td></tr>
<tr class="memitem:ga4642e063421a9ed631a18c6454301e1f"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class DepthMap , class T &gt; </td></tr>
<tr class="memitem:ga4642e063421a9ed631a18c6454301e1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga4642e063421a9ed631a18c6454301e1f">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, const Array3 &amp;out, const DepthMap &amp;dmap, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, bool apply_and_operation, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga4642e063421a9ed631a18c6454301e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga4642e063421a9ed631a18c6454301e1f"></a><br/></td></tr>
<tr class="memitem:ga5415877fd06f61fe42ba57a02f1a907e"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class T &gt; </td></tr>
<tr class="memitem:ga5415877fd06f61fe42ba57a02f1a907e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga5415877fd06f61fe42ba57a02f1a907e">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, typename Array1::size_type image_width, typename Array1::size_type image_height, double resoX, double resoY, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga5415877fd06f61fe42ba57a02f1a907e"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga5415877fd06f61fe42ba57a02f1a907e"></a><br/></td></tr>
<tr class="memitem:ga69b3bdf29d8c432b3bc06fbb5bb1b9a1"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class T &gt; </td></tr>
<tr class="memitem:ga69b3bdf29d8c432b3bc06fbb5bb1b9a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga69b3bdf29d8c432b3bc06fbb5bb1b9a1">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, const Array3 &amp;out, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga69b3bdf29d8c432b3bc06fbb5bb1b9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga69b3bdf29d8c432b3bc06fbb5bb1b9a1"></a><br/></td></tr>
<tr class="memitem:ga86483bf4bb7e614a621b788017c18af8"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class T &gt; </td></tr>
<tr class="memitem:ga86483bf4bb7e614a621b788017c18af8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga86483bf4bb7e614a621b788017c18af8">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, typename Array1::size_type image_width, typename Array1::size_type image_height, double resoX, double resoY, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, bool apply_and_operation, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga86483bf4bb7e614a621b788017c18af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga86483bf4bb7e614a621b788017c18af8"></a><br/></td></tr>
<tr class="memitem:ga345af1090a57d1eab7b668cdb91e82d6"><td class="memTemplParams" colspan="2">template&lt;class Array1 , class Array2 , class Array3 , class T &gt; </td></tr>
<tr class="memitem:ga345af1090a57d1eab7b668cdb91e82d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmist_1_1vector3.html">volumerender::parameter::vector_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga345af1090a57d1eab7b668cdb91e82d6">collision_detection</a> (const Array1 &amp;in, const Array2 &amp;mk, const Array3 &amp;out, const volumerender::parameter &amp;param, const volumerender::attribute_table&lt; T &gt; &amp;table, const volumerender::attribute_table&lt; T &gt; &amp;mktable, bool apply_and_operation, typename Array1::size_type i, typename Array1::size_type j)</td></tr>
<tr class="memdesc:ga345af1090a57d1eab7b668cdb91e82d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">衝突判定ルーチン（MISTのボリュームレンダリングエンジンで利用）  <a href="group__volumerendering__group.html#ga345af1090a57d1eab7b668cdb91e82d6"></a><br/></td></tr>
<tr class="memitem:ga4fb3a2763da5beebdba291a08e977b00"><td class="memTemplParams" colspan="2">template&lt;class Array , class DepthMap , class ATTRIBUTETYPE &gt; </td></tr>
<tr class="memitem:ga4fb3a2763da5beebdba291a08e977b00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__volumerendering__group.html#ga4fb3a2763da5beebdba291a08e977b00">generate_depth_map</a> (const Array &amp;in, DepthMap &amp;dmap, const volumerender::attribute_table&lt; ATTRIBUTETYPE &gt; &amp;table, typename Array::size_type thread_num=0)</td></tr>
<tr class="memdesc:ga4fb3a2763da5beebdba291a08e977b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">ボリュームレンダリング  <a href="group__volumerendering__group.html#ga4fb3a2763da5beebdba291a08e977b00"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>説明</h2>
<div class="textblock"><p>MISTプロジェクトの名前空間． すべての関数・クラスは mist 名前空間に含まれる． </p>
</div><h2>関数</h2>
<a class="anchor" id="a386c548a90409bdbbbb5573b48d9eae7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mist::autocorrelation </td>
          <td>(</td>
          <td class="paramtype">const array1&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>biased</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Autocorrelation. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>is input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>is lag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biased</td><td>is normalization factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>autocorrelation value </dd></dl>

<p>参照先 <a class="el" href="namespacemist.html#a386c548a90409bdbbbb5573b48d9eae7">autocorrelation()</a>, と <a class="el" href="namespacemist.html#aa9b4500a2d074b160500029dea1cff68">cross_correlation()</a>.</p>

<p>参照元 <a class="el" href="namespacemist.html#a386c548a90409bdbbbb5573b48d9eae7">autocorrelation()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9b4500a2d074b160500029dea1cff68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mist::cross_correlation </td>
          <td>(</td>
          <td class="paramtype">const array1&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>signal1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array1&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>signal2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>biased</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross correlation. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal1</td><td>is input data 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal2</td><td>is input data 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>is lag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">biased</td><td>is normalization factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>cross correlation value </dd></dl>

<p>参照先 <a class="el" href="namespacemist.html#aa9b4500a2d074b160500029dea1cff68">cross_correlation()</a>, と <a class="el" href="classmist_1_1array.html#ab44cda26c6af5e5276b12faee45881c4">mist::array&lt; T, Allocator &gt;::size()</a>.</p>

<p>参照元 <a class="el" href="namespacemist.html#a386c548a90409bdbbbb5573b48d9eae7">autocorrelation()</a>, と <a class="el" href="namespacemist.html#aa9b4500a2d074b160500029dea1cff68">cross_correlation()</a>.</p>

</div>
</div>
<a class="anchor" id="a86de595cc64ee97e461132690b61fa37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mist::cut_detection </td>
          <td>(</td>
          <td class="paramtype">video::decoder &amp;&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_indeces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>red_bin</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>green_bin</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blue_bin</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold_of_similarity</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>number_of_between_frames</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ビデオストリームを入力し，ビデオ内のカット位置を検出する </p>
<div class="fragment"><div class="line"> 使い方</div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mist_8h.html" title="MISTの基本となる音声・画像を扱うコンテナ">mist/mist.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="video_8h.html" title="さまざまなビデオストリームの入出力ライブラリ">mist/io/video.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bmp_8h.html" title="ビットマップ画像を読み書きするためのライブラリ">mist/io/bmp.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html" title="経過時間を計算するクラス">mist/timer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mist/media/cut.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> mist::video::decoder::size_type       size_type;</div>
<div class="line">    <span class="keyword">typedef</span> mist::video::decoder::difference_type difference_type;</div>
<div class="line">    <a class="code" href="classmist_1_1video_1_1decoder.html" title="ビデオ入力クラス">mist::video::decoder</a> iv;</div>
<div class="line">    std::string filename = <span class="stringliteral">&quot;入力ビデオファイル名&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( !iv.<a class="code" href="classmist_1_1video_1_1decoder.html#af6b96cc556a6178a442ba769a2055535" title="ファイルから入力用ビデオストリームを開く">open</a>( filename ) )</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open video file [&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span>( 1 );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::vector&lt; int &gt; indeces;</div>
<div class="line">    <a class="code" href="namespacemist.html#a86de595cc64ee97e461132690b61fa37" title="ビデオストリームを入力し，ビデオ内のカット位置を検出する">mist::cut_detection</a>( iv, indeces, 8, 8, 8, 0.95, 30 );</div>
<div class="line"></div>
<div class="line">    iv.<a class="code" href="classmist_1_1video_1_1decoder.html#ada75253dadcea559c19acb9152042e82" title="ビデオストリームを閉じる">close</a>( );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// 再度ファイルを開く</span></div>
<div class="line">    <span class="keywordflow">if</span>( !iv.<a class="code" href="classmist_1_1video_1_1decoder.html#af6b96cc556a6178a442ba769a2055535" title="ファイルから入力用ビデオストリームを開く">open</a>( filename ) )</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open video file [&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span>( 1 );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmist_1_1array2.html" title="要素数が可変の解像度付き2次元配列">mist::array2&lt; mist::rgb&lt; unsigned char &gt;</a> &gt; img;</div>
<div class="line">    <span class="keywordflow">for</span>( size_type i = 1 ; i &lt; indeces.size( ) ; i++ )</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; indeces[ i ] &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">char</span> fname[ 256 ];</div>
<div class="line">        sprintf( fname, <span class="stringliteral">&quot;%04d-%04d.avi&quot;</span>, indeces[ i - 1 ], indeces[ i ] );</div>
<div class="line">        <a class="code" href="classmist_1_1video_1_1mpeg4_1_1encoder.html" title="MPEG4ビデオ出力クラス">mist::video::mpeg4::encoder</a> ov( fname, iv.<a class="code" href="classmist_1_1video_1_1decoder.html#a32e27d51a6c4817703eab575f853645a" title="フレームの幅を得る">width</a>( ), iv.<a class="code" href="classmist_1_1video_1_1decoder.html#a4fa7cd228de4ec4415bc091b3ce60136" title="フレームの高さを得る">height</a>( ), 1, 30 );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">while</span>( !iv.<a class="code" href="classmist_1_1video_1_1decoder.html#a9fec1c1301287be749d33e3b4bcc264f" title="ビデオストリームの終わりに来たかどうかを返す">is_eof</a>( ) &amp;&amp; iv.<a class="code" href="classmist_1_1video_1_1decoder.html#a781b1bde4fb8b4a70bcf0cbc52885b16" title="現在のビデオストリーム上での再生位置を表す秒数">frame_id</a>( ) &lt; indeces[ i ] )</div>
<div class="line">        {</div>
<div class="line">            iv &gt;&gt; img;</div>
<div class="line">            ov &lt;&lt; img;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        ov.close( );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span>( 0 );</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>… カット検出を行うビデオファイルを開いた <a class="el" href="classmist_1_1video_1_1decoder.html" title="ビデオ入力クラス">mist::video::decoder</a> オブジェクト </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frame_indeces</td><td>… カット位置を出力するリスト </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">red_bin</td><td>… 赤色成分のビン数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">green_bin</td><td>… 緑色成分のビン数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blue_bin</td><td>… 青色成分のビン数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_of_similarity</td><td>… 色ヒストグラムの正規化相関に対するしきい値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_between_frames</td><td>… カット間の最小フレーム間隔</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>戻り値</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>… カットの検出に成功 </td></tr>
    <tr><td class="paramname">false</td><td>… カットの検出に失敗 </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="classmist_1_1video_1_1decoder.html#a781b1bde4fb8b4a70bcf0cbc52885b16">mist::video::decoder::frame_id()</a>, <a class="el" href="classmist_1_1video_1_1decoder.html#a9fec1c1301287be749d33e3b4bcc264f">mist::video::decoder::is_eof()</a>, <a class="el" href="classmist_1_1video_1_1decoder.html#a6237e60397d73932f180a9abffff112f">mist::video::decoder::read()</a>, と <a class="el" href="classmist_1_1array3.html#a5a36dcc005da83a00b1275b949cd66c6">mist::array3&lt; T, Allocator &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac621dd7adbc4d81ad1d16e2d64968f23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mist::homography_matrix </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate homography matrix </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mat</td><td>is homography matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1,p2</td><td>are input matrix(2x4) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>success of calculation </dd></dl>

<p>参照先 <a class="el" href="classmist_1_1matrix.html#a8dc20bfab4b7003a9ba0ecad0d0cf684">mist::matrix&lt; T, Allocator &gt;::cols()</a>, <a class="el" href="classmist_1_1matrix.html#a344bfa81522dc2e3f5e2ddc92c785502">mist::matrix&lt; T, Allocator &gt;::resize()</a>, <a class="el" href="classmist_1_1matrix.html#a294c15b9a0d9cdcf42fba8e4cb71994f">mist::matrix&lt; T, Allocator &gt;::rows()</a>, と <a class="el" href="group__numeric__group.html#ga5f85b437b93dc620f245de814b76ba45">svd()</a>.</p>

</div>
</div>
<a class="anchor" id="afeb4393ea1a69bfbabde03b68dace5c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TV , typename TA , typename MV , typename MA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mist::hosvd </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; 2, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor&lt; 2, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply higher order singular value decomposition (HOSVD) to a 2nd order tensor </p>
<p>HOSVD decomposes a 2nd order tensor T as T = Z  U_1  U_2. Here U_1 and U_2 are unitary matrices and a 2nd order tensor Z is called as a core tensor. Using 1-mode-unfolding matrix of T, this is described like SVD of a matrix as T_1 = U_1 S U_2^t Here S is a singular value matrix.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor to be decomposed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>core tensor of the tensor </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u1</td><td>unitary matrix corresponding to the 1st mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u2</td><td>unitary matrix corresponding to the 2nd mode </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="classmist_1_1tensor.html#a63ee82385cbbc7ac6bf1eb9ae9b8fad6">mist::tensor&lt; M, V, A &gt;::hosvd()</a>.</p>

</div>
</div>
<a class="anchor" id="a2264c6a7020ead7e633ab9d993414be3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TV , typename TA , typename MV , typename MA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mist::hosvd </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; 3, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor&lt; 3, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply higher order singular value decomposition (HOSVD) to a 3rd order tensor </p>
<p>HOSVD decomposes a 3rd order tensor T as T = Z  U_1  U_2  U_3. Here U_1, U_2, and U_3 are unitary matrices and a 3rd order tensor Z is called as a core tensor.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>tensorto be decomposed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>core tensor of the tensor </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u1</td><td>unitary matrix corresponding to the 1st mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u2</td><td>unitary matrix corresponding to the 2nd mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u3</td><td>unitary matrix corresponding to the 3rd mode </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="classmist_1_1tensor.html#a63ee82385cbbc7ac6bf1eb9ae9b8fad6">mist::tensor&lt; M, V, A &gt;::hosvd()</a>.</p>

</div>
</div>
<a class="anchor" id="a84544efc033853ec645e806f2c61cc14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TV , typename TA , typename MV , typename MA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mist::hosvd </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; 4, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor&lt; 4, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply higher order singular value decomposition (HOSVD) to a 4th order tensor </p>
<p>HOSVD decomposes a 4th order tensor T as T = Z  U_1  U_2  U_3  U_4. Here U_1, U_2, U_3 and U_4 are unitary matrices and a 4th order tensor Z is called as a core tensor.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>tensorto be decomposed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>core tensor of the tensor </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u1</td><td>unitary matrix corresponding to the 1st mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u2</td><td>unitary matrix corresponding to the 2nd mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u3</td><td>unitary matrix corresponding to the 3rd mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u4</td><td>unitary matrix corresponding to the 4th mode </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="classmist_1_1tensor.html#a63ee82385cbbc7ac6bf1eb9ae9b8fad6">mist::tensor&lt; M, V, A &gt;::hosvd()</a>.</p>

</div>
</div>
<a class="anchor" id="a42b408762e7f1956b79d9bf683d85a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TV , typename TA , typename MV , typename MA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mist::hosvd </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; 5, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor&lt; 5, TV, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; MV, MA &gt; &amp;&#160;</td>
          <td class="paramname"><em>u5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply higher order singular value decomposition (HOSVD) to a 5th order tensor </p>
<p>HOSVD decomposes a 5th order tensor T as T = Z  U_1  U_2  U_3  U_4  U_5. Here U_1, U_2, U_3 and U_4 are unitary matrices and a 5th order tensor Z is called as a core tensor.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>tensorto be decomposed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>core tensor of the tensor </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u1</td><td>unitary matrix corresponding to the 1st mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u2</td><td>unitary matrix corresponding to the 2nd mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u3</td><td>unitary matrix corresponding to the 3rd mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u4</td><td>unitary matrix corresponding to the 4th mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u5</td><td>unitary matrix corresponding to the 5th mode </td></tr>
  </table>
  </dd>
</dl>

<p>参照先 <a class="el" href="classmist_1_1tensor.html#a63ee82385cbbc7ac6bf1eb9ae9b8fad6">mist::tensor&lt; M, V, A &gt;::hosvd()</a>.</p>

</div>
</div>
<a class="anchor" id="a416c4e90fbe4e1ecb13ea585d80a77b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; double &gt; mist::interpolate </td>
          <td>(</td>
          <td class="paramtype">const quaternion&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const quaternion&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>球面線形補間を行う </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q1</td><td>… 補間もとのクォータニオン1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q2</td><td>… 補間もとのクォータニオン2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>… [0,1]の間の数値で，補間点</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>球面線形補間されたクォータニオン </dd></dl>

<p>参照先 <a class="el" href="classmist_1_1quaternion.html#a88cd2376b5dc5628ed58931ea141d3b7">mist::quaternion&lt; T &gt;::inner()</a>, と <a class="el" href="classmist_1_1quaternion.html#a496466c75745d22be3697ccb67d7009f">mist::quaternion&lt; T &gt;::unit()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bc34e9d99c662547e0a48b33ec93710"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object1 , class Object2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mist::is_same_object </td>
          <td>(</td>
          <td class="paramtype">const Object1 &amp;&#160;</td>
          <td class="paramname"><em>o1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Object2 &amp;&#160;</td>
          <td class="paramname"><em>o2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>入力された2つのオブジェクトが同じもの（メモリ上で同じ位置にある）かどうかを判定する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">o1</td><td>… オブジェクト1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o2</td><td>… オブジェクト2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>true … 入力された2つのオブジェクトは，メモリ上で同じ位置に存在している </dd>
<dd>
false … 入力された2つのオブジェクトは，別のメモリ上に存在している </dd></dl>

<p>参照元 <a class="el" href="namespacemist_1_1linear.html#a54e884bd5f359e6bff8bea54a552c371">mist::linear::filter()</a>, <a class="el" href="namespacemist_1_1average.html#a1ab64b54635d4221ca312d4150ca68e4">mist::average::filter()</a>, <a class="el" href="group__volumerendering__group.html#ga4fb3a2763da5beebdba291a08e977b00">generate_depth_map()</a>, <a class="el" href="group__statistics__group.html#ga230684939d7f54813e0f7a1801e6766d">mist::statistics::generate_histogram()</a>, <a class="el" href="namespacemist_1_1nearest.html#aad0452b0a3601b1252c9e83e32ee7b19">mist::nearest::interpolate()</a>, <a class="el" href="namespacemist_1_1mean.html#a38cffb2c680d260aef074cd08643f4d4">mist::mean::interpolate()</a>, <a class="el" href="namespacemist_1_1linear.html#aebe0771229542cdeba0260f21d94da22">mist::linear::interpolate()</a>, <a class="el" href="namespacemist_1_1cubic.html#ac7e51c96515f3a977424a7264b600dc1">mist::cubic::interpolate()</a>, <a class="el" href="namespacemist_1_1BSpline.html#a38f32e7434c4422d9adf60214b491321">mist::BSpline::interpolate()</a>, <a class="el" href="namespacemist_1_1sinc.html#aab90587eca67e728fcbc549c3fa422db">mist::sinc::interpolate()</a>, <a class="el" href="group__median__group.html#ga5941dca528cb1a97a876e50507785833">median()</a>, <a class="el" href="group__volumerendering__group.html#gaf8030793cad706695326d2b7da38e3b6">mip()</a>, <a class="el" href="group__region__growing__group.html#gabae77324d51d95c848be61462fd817e5">region_growing()</a>, と <a class="el" href="group__volumerendering__group.html#ga387d2cf52eb6e643c67922cd8cb140af">volumerendering()</a>.</p>

</div>
</div>
<a class="anchor" id="ad12f9a00a4f50f1aca5f71eb3818dff3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mist::mist_debug_assertion </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEBUGでMISTをビルドした際に，1次元アクセスでの範囲外アクセスをチェックし，エラーの際に呼ばれる関数． </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>… MISTコンテナに対するアクセス要求位置 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed63acbca1916d5d2df4b0462c10fcc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mist::mist_debug_assertion </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEBUGでMISTをビルドした際に，2次元アクセスでの範囲外アクセスをチェックし，エラーの際に呼ばれる関数． </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index1</td><td>… MISTコンテナに対するX軸でのアクセス要求位置 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index2</td><td>… MISTコンテナに対するY軸でのアクセス要求位置 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96b299db390c5461be02f73c4394dc16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mist::mist_debug_assertion </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>index3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEBUGでMISTをビルドした際に，3次元アクセスでの範囲外アクセスをチェックし，エラーの際に呼ばれる関数． </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index1</td><td>… MISTコンテナに対するX軸でのアクセス要求位置 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index2</td><td>… MISTコンテナに対するY軸でのアクセス要求位置 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index3</td><td>… MISTコンテナに対するZ軸でのアクセス要求位置 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada03b8c07dc2afd518e2195778b69843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, typename V , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; mist::operator* </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename type_trait&lt; V &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiplication operator to calculate product of a tensor and a value </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>product of the tensor and the value </dd></dl>

</div>
</div>
<a class="anchor" id="a694eede7a367296762843fd1a6d6c213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, typename V , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; mist::operator* </td>
          <td>(</td>
          <td class="paramtype">const typename type_trait&lt; V &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiplication operator to calculate product of a value and a tensor </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>product of the value and the tensor </dd></dl>

</div>
</div>
<a class="anchor" id="a0790291fd486c1f783c7dac7bbde12c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator* </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>掛け算 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>… 左辺値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>… 右辺値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>掛け算結果 </dd></dl>

</div>
</div>
<a class="anchor" id="a7bcf2817675a41959d87d536e864b3a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator* </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename type_trait&lt; T &gt;::value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>定数との掛け算 </p>
<p>詳細な説明や関数の使用例を書く</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 行列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>… 定数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>左辺値の行列を定数倍した結果 </dd></dl>

</div>
</div>
<a class="anchor" id="a514da56f0a006923be7523ca346d506a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator* </td>
          <td>(</td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>定数との掛け算 </p>
<p>詳細な説明や関数の使用例を書く</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>… 定数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 行列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>右辺値の行列を定数倍した結果 </dd></dl>

</div>
</div>
<a class="anchor" id="ab9fb1569d902b877a7ad34c8ff42d650"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, typename V , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; mist::operator+ </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>addition operator to calculate summation of two tensors </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t1</td><td>1st tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t2</td><td>2nd tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>summation of the 1st tensor and the 2nd tensor </dd></dl>

</div>
</div>
<a class="anchor" id="ac3a6973bb47d8ca035824599240b0e8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator+ </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>足し算 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>… 左辺値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>… 右辺値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>足し算結果 </dd></dl>

</div>
</div>
<a class="anchor" id="a466c47241a60a5af94c7a6df2889f67e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator+ </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename type_trait&lt; T &gt;::value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>単位行列の定数倍との足し算 </p>
<p>詳細な説明や関数の使用例を書く</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 行列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>… 定数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>左辺値の行列に単位行列の定数倍を足し算した結果 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb25d48aff8ef3f633d301e6db75696b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>定数との足し算 </p>
<p>詳細な説明や関数の使用例を書く</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>… 定数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 行列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>右辺値の行列に単位行列の定数倍を足し算した結果 </dd></dl>

</div>
</div>
<a class="anchor" id="a37610ff35a42dc00727926aa2422603c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, typename V , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; mist::operator- </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>subtraction operator to calculate difference betwwen two tensors </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t1</td><td>1st tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t2</td><td>2nd tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>difference between the 1st tensor and the 2nd tensor </dd></dl>

</div>
</div>
<a class="anchor" id="afe4b92258c37027b49b0a219fcd62e92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator- </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>引き算 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>… 左辺値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>… 右辺値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>引き算結果 </dd></dl>

</div>
</div>
<a class="anchor" id="acadf0c903a1232ba1c25e785a13aa53b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator- </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename type_trait&lt; T &gt;::value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>定数との引き算 </p>
<p>詳細な説明や関数の使用例を書く</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 行列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>… 定数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>左辺値の行列から，単位行列を定数倍したものを引き算した結果 </dd></dl>

</div>
</div>
<a class="anchor" id="a7ca5606a41b6033da4884567c28163ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator- </td>
          <td>(</td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>定数との引き算 </p>
<p>詳細な説明や関数の使用例を書く</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>… 定数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 行列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>単位行列を定数倍したものから右辺値の行列を引き算した結果 </dd></dl>

</div>
</div>
<a class="anchor" id="ae76e32fb5ed29261feca6558fed16642"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, typename V , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1tensor.html">tensor</a>&lt; M, V, A &gt; mist::operator/ </td>
          <td>(</td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename type_trait&lt; V &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>division operator to calculate quotient of a tensor and a value </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>quotient of the tensor and the value </dd></dl>

</div>
</div>
<a class="anchor" id="a9f3ff2cc7d439692dfb38b507443b7a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmist_1_1matrix.html">matrix</a>&lt; T, Allocator &gt; mist::operator/ </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename type_trait&lt; T &gt;::value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>詳細な説明や関数の使用例を書く</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 行列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>… 定数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>左辺値の行列を定数で割り算した結果 </dd></dl>

</div>
</div>
<a class="anchor" id="a5942791f8f865a86f65267109d54aab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">::std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timer &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>経過時間を標準出力に出力する． </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 引数の説明 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>… 引数の説明</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>戻り値の説明 </dd></dl>

<p>参照先 <a class="el" href="classmist_1_1timer.html#a6736962dfa03cfccbe4a000ed9a34aa3">mist::timer::elapse()</a>.</p>

</div>
</div>
<a class="anchor" id="a79d8f91cb3624875a3b23c60c4da932d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">::std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stopwatch &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>経過時間を標準出力に出力する． </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 引数の説明 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>… 引数の説明</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>戻り値の説明 </dd></dl>

<p>参照先 <a class="el" href="classmist_1_1stopwatch.html#a3f97447e17217b68d484360dd478b10a">mist::stopwatch::elapse()</a>.</p>

</div>
</div>
<a class="anchor" id="a6716e367d9065508b7b197f151ab713b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const binary &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定されたストリームに，コンテナ内の要素を整形して出力する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>… バイナリ画素</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">1</div>
</div><!-- fragment --> 
<p>参照先 <a class="el" href="classmist_1_1binary.html#ac1f58571f54ea8ef3df5f6e4034f9f06">mist::binary::get_value()</a>.</p>

</div>
</div>
<a class="anchor" id="a39980026a4d55f5bb3a12c0684f2dc72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stereo&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ステレオ音声データの和 </p>
<p>ステレオ音声データと定数の和 定数とステレオ音声データの和 ステレオ音声データの差 ステレオ音声データと定数の差 定数とステレオ音声データの差 ステレオ音声データの積 ステレオ音声データと定数の積 定数とステレオ音声データの積 ステレオ音声データの割り算 ステレオ音声データを定数で割る ステレオ音声データの剰余 ステレオ音声データの | 演算 ステレオ音声データの &amp; 演算 ステレオ音声データの ^ 演算 指定されたストリームに，コンテナ内の要素を整形して出力する</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>… ステレオ音声</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">( 1, 2 )</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a59e0301c0d45c4af3a57b0cc117c644a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BITS, class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitmap&lt; BITS, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定されたストリームに，コンテナ内の要素を整形して出力する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>… bitmap 配列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">1, 2, 3, 4</div>
<div class="line">5, 6, 7, 8</div>
<div class="line">9, 10, 11, 12</div>
</div><!-- fragment --> 
<p>参照先 <a class="el" href="classmist_1_1bitmap.html#a00363acec125ebaf30a5a5afa5819bba">mist::bitmap&lt; BITS, Allocator &gt;::size1()</a>, と <a class="el" href="classmist_1_1bitmap.html#aff102841e3bdd7128a60befbfd58f0a2">mist::bitmap&lt; BITS, Allocator &gt;::size2()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c6f361cc4ffaf3848f4dec810ab27ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>クォータニオンの和 </p>
<p>クォータニオンと定数の和 定数とクォータニオンの和 クォータニオンの差 クォータニオンと定数の差 定数とクォータニオンの差 クォータニオンの積 クォータニオンと定数の積 定数とクォータニオンの積 クォータニオンの割り算 クォータニオンを定数で割る 指定されたストリームに，コンテナ内の要素を整形して出力する</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>… クォータニオン</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">( 1, 2, 3, 4 )</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abc313580631612db62b33ba97db28e82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, typename V , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">::std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tensor&lt; M, V, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output stream operator </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>output stream </dd></dl>

</div>
</div>
<a class="anchor" id="a91e2273b32d5b97d2d06d37a4037c757"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">::std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたストリームに，行列内の要素を整形して出力する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>… 出力する行列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">1, 4, 7</div>
<div class="line">2, 5, 8</div>
<div class="line">3, 6, 9</div>
</div><!-- fragment --> 
<p>参照先 <a class="el" href="classmist_1_1matrix.html#a8dc20bfab4b7003a9ba0ecad0d0cf684">mist::matrix&lt; T, Allocator &gt;::cols()</a>, と <a class="el" href="classmist_1_1matrix.html#a294c15b9a0d9cdcf42fba8e4cb71994f">mist::matrix&lt; T, Allocator &gt;::rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a502570f7489d976b2ead6749dccfb133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定されたストリームに，コンテナ内の要素を整形して出力する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>… array 配列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">1, 2, 3, 4</div>
</div><!-- fragment --> 
<p>参照先 <a class="el" href="classmist_1_1array.html#ab44cda26c6af5e5276b12faee45881c4">mist::array&lt; T, Allocator &gt;::size()</a>, と <a class="el" href="classmist_1_1array.html#a6dcabd40f018657d56fa48565b07fa13">mist::array&lt; T, Allocator &gt;::size1()</a>.</p>

</div>
</div>
<a class="anchor" id="add166b75cc203f6b542f4d6c6ca8293b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array1&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定されたストリームに，コンテナ内の要素を整形して出力する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>… <a class="el" href="classmist_1_1array1.html" title="要素数が可変の解像度付1次元配列">array1</a> 配列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">1, 2, 3, 4</div>
</div><!-- fragment --> 
<p>参照先 <a class="el" href="classmist_1_1array.html#ab44cda26c6af5e5276b12faee45881c4">mist::array&lt; T, Allocator &gt;::size()</a>, と <a class="el" href="classmist_1_1array.html#a6dcabd40f018657d56fa48565b07fa13">mist::array&lt; T, Allocator &gt;::size1()</a>.</p>

</div>
</div>
<a class="anchor" id="a77cc71d72e4e0689b1371fa426868853"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array2&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定されたストリームに，コンテナ内の要素を整形して出力する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>… <a class="el" href="classmist_1_1array2.html" title="要素数が可変の解像度付き2次元配列">array2</a> 配列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">1, 2, 3, 4</div>
<div class="line">5, 6, 7, 8</div>
<div class="line">9, 10, 11, 12</div>
</div><!-- fragment --> 
<p>参照先 <a class="el" href="classmist_1_1array2.html#ab6ecb95961c8f9e8f0cfa3ec9964e356">mist::array2&lt; T, Allocator &gt;::size1()</a>, と <a class="el" href="classmist_1_1array2.html#a8c8a04c195a6b969accb6b80a874129f">mist::array2&lt; T, Allocator &gt;::size2()</a>.</p>

</div>
</div>
<a class="anchor" id="af8edde19003a031bd76688042d598999"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mist::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array3&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定されたストリームに，コンテナ内の要素を整形して出力する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>… 入力と出力を行うストリーム </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>… <a class="el" href="classmist_1_1array3.html" title="要素数が可変の解像度付き3次元配列">array3</a> 配列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>入力されたストリーム</dd></dl>
<div class="fragment"><div class="line"> 出力例</div>
<div class="line">1, 2, 3, 4</div>
<div class="line">5, 6, 7, 8</div>
<div class="line">9, 10, 11, 12</div>
<div class="line">----- separator -----</div>
<div class="line">1, 2, 3, 4</div>
<div class="line">5, 6, 7, 8</div>
<div class="line">9, 10, 11, 12</div>
</div><!-- fragment --> 
<p>参照先 <a class="el" href="classmist_1_1array3.html#a0d7b4197964d6eed9ce23aa24f016b79">mist::array3&lt; T, Allocator &gt;::size1()</a>, <a class="el" href="classmist_1_1array3.html#af610c89e037e6ef03fe488abe994b4fd">mist::array3&lt; T, Allocator &gt;::size2()</a>, と <a class="el" href="classmist_1_1array3.html#a8e779970f1f14abe6a70bc87e2e1465e">mist::array3&lt; T, Allocator &gt;::size3()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e529d6681f45a72fb06d36ead8d0ee3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class Allocator1 , class T2 , class Allocator2 , class T3 , class Allocator3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mist::parcor </td>
          <td>(</td>
          <td class="paramtype">const array1&lt; T1, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array1&lt; T2, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array1&lt; T3, Allocator3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate PARCOR and linear predict cofficients from autocorrelation values. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cor</td><td>is autocorrelation values (the length should be p + 1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">alf</td><td>is linear predict cofficients </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ref</td><td>is PARCOR cofficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>is number of cofficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>residual </dd></dl>

<p>参照先 <a class="el" href="namespacemist.html#a8e529d6681f45a72fb06d36ead8d0ee3">parcor()</a>, と <a class="el" href="classmist_1_1array.html#ab2b09cc3b61f7dc9bb120ed876003705">mist::array&lt; T, Allocator &gt;::resize()</a>.</p>

<p>参照元 <a class="el" href="namespacemist.html#a8e529d6681f45a72fb06d36ead8d0ee3">parcor()</a>.</p>

</div>
</div>
<a class="anchor" id="a64ba8af07977af38891e18fc2558dc18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mist::rotation_matrix </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>radian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate rotation matrix </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mat</td><td>is rotation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>is rotation angle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a4bb6fee2b1641a2951fcb5a40b944a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mist::rotation_matrix </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>radian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate rotation matrix </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mat</td><td>is rotation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>is rotation angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cx</td><td>is X coordinate of the rotation center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cy</td><td>is Y coordinate of the rotation center </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afede2b385e98e06e5571bd1b7f055fee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mist::scaling_matrix </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate scaling matrix </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mat</td><td>is scaling matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sx,sy</td><td>is scale </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a729e367dc6a47602a4bdee4635ead73c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt; mist::track_ball </td>
          <td>(</td>
          <td class="paramtype">const vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt;&#160;</td>
          <td class="paramname"><em>axisY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt;&#160;</td>
          <td class="paramname"><em>axisZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>trackball_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>仮想トラックボールの実装(左手座標系) </p>
<dl class="section note"><dt>覚え書き</dt><dd>以下のソースコードを参考にした</dd></dl>
<p>Trackball code:</p>
<p>Implementation of a virtual trackball. Implemented by Gavin Bell, lots of ideas from Thant Tessman and the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.</p>
<p>Vector manip code:</p>
<p>Original code from: David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli</p>
<p>Much mucking with by: Gavin Bell</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>… 回転前の点 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>… 回転後の点 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisX</td><td>… トラックボールのX軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisY</td><td>… トラックボールのY軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisZ</td><td>… トラックボールのZ軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trackball_size</td><td>… トラックボールの半径（デフォルトは0.8）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>回転を表すクォータニオン </dd></dl>

<p>参照先 <a class="el" href="classmist_1_1vector2.html#adfe8b2d2a8adc177a2e336a0199e3ad2">mist::vector2&lt; T &gt;::length()</a>, <a class="el" href="classmist_1_1vector3.html#af8bc62562bfcf84e19b8c460c90eb87b">mist::vector3&lt; T &gt;::x</a>, <a class="el" href="classmist_1_1vector2.html#af68bdd4edd7479a3e5173dd47c7881be">mist::vector2&lt; T &gt;::x</a>, <a class="el" href="classmist_1_1vector3.html#ad713c6bf4aceb2b61dec9dfca7175bd3">mist::vector3&lt; T &gt;::y</a>, <a class="el" href="classmist_1_1vector2.html#ad8df8b8e6bdcd20c4507827fbf4d9f6b">mist::vector2&lt; T &gt;::y</a>, と <a class="el" href="classmist_1_1vector3.html#a65670ab9189ceb952f9ac1f7684cf567">mist::vector3&lt; T &gt;::z</a>.</p>

<p>参照元 <a class="el" href="namespacemist.html#a68bb87edf3accc81e8b5ed12dfbdd717">track_ball()</a>.</p>

</div>
</div>
<a class="anchor" id="a68bb87edf3accc81e8b5ed12dfbdd717"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt; mist::track_ball </td>
          <td>(</td>
          <td class="paramtype">const vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt;&#160;</td>
          <td class="paramname"><em>axisY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt;&#160;</td>
          <td class="paramname"><em>axisZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>仮想トラックボールの実装(左手座標系) </p>
<dl class="section note"><dt>覚え書き</dt><dd>以下のソースコードを参考にした</dd></dl>
<p>Trackball code:</p>
<p>Implementation of a virtual trackball. Implemented by Gavin Bell, lots of ideas from Thant Tessman and the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.</p>
<p>Vector manip code:</p>
<p>Original code from: David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli</p>
<p>Much mucking with by: Gavin Bell</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>… 回転前の点 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>… 回転後の点 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisX</td><td>… トラックボールのX軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisY</td><td>… トラックボールのY軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisZ</td><td>… トラックボールのZ軸</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>回転を表すクォータニオン </dd></dl>

<p>参照先 <a class="el" href="namespacemist.html#a729e367dc6a47602a4bdee4635ead73c">track_ball()</a>.</p>

</div>
</div>
<a class="anchor" id="a346202ee02abebad2f521b4bc4e8dd54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt; mist::track_ball </td>
          <td>(</td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>trackball_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>仮想トラックボールの実装(左手座標系) </p>
<p>トラックボールを用いて，任意ベクトルの回転を行う</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>… 回転前のX座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>… 回転前のY座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>… 回転後のX座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>… 回転後のY座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisX</td><td>… トラックボールのX軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisY</td><td>… トラックボールのY軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisZ</td><td>… トラックボールのZ軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trackball_size</td><td>… トラックボールの半径（デフォルトは0.8）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>回転を表すクォータニオン </dd></dl>

<p>参照先 <a class="el" href="namespacemist.html#a729e367dc6a47602a4bdee4635ead73c">track_ball()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7784dceff9f4ce63b4ebad61470eb3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmist_1_1quaternion.html">quaternion</a>&lt; T &gt; mist::track_ball </td>
          <td>(</td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename vector3&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>仮想トラックボールの実装(左手座標系) </p>
<p>トラックボールを用いて，任意ベクトルの回転を行う</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>… 回転前のX座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>… 回転前のY座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td>… 回転後のX座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y2</td><td>… 回転後のY座標 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisX</td><td>… トラックボールのX軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisY</td><td>… トラックボールのY軸 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axisZ</td><td>… トラックボールのZ軸</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>回転を表すクォータニオン </dd></dl>

<p>参照先 <a class="el" href="namespacemist.html#a729e367dc6a47602a4bdee4635ead73c">track_ball()</a>.</p>

</div>
</div>
<a class="anchor" id="adca49273c7ff92351816821784f7ca6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mist::translation_matrix </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Allocator &gt;::value_type&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate translation matrix </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mat</td><td>is translation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y</td><td>is position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2f799d2c98c030f7bc5ba23c8fb0380"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string mist::wstr2str </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UNICODE文字列をマルチバイト文字列に変換する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>… UNICODE文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>マルチバイト文字列 </dd></dl>

<p>参照先 <a class="el" href="group__dst__group.html#ga2b34d712ac7c0b9ad9ad3f974134a762">dst()</a>.</p>

<p>参照元 <a class="el" href="group__image__bmp__group.html#gace5138da5cc309ff328fe910427b7e41">read_bmp()</a>, <a class="el" href="group__csv__data__group.html#ga44ea8d02b256a85839078c63511dc5c7">read_csv()</a>, <a class="el" href="group__image__gif__group.html#gaf26344e08b2a0e8a5c0c8b8f8ad92b5c">read_gif()</a>, <a class="el" href="group__image__group.html#ga001405abc0f5202cc0c9fc49a6ea3617">read_image()</a>, <a class="el" href="group__image__jpeg__group.html#ga27e9e380d70eb60aa370d30936dfda59">read_jpeg()</a>, <a class="el" href="group__image__jpeg2000__group.html#gaf3c98a41710f72d25b809566446c4812">read_jpeg2000()</a>, <a class="el" href="group__lines__data__group.html#gae70c41a96b1ee66e7c58ceec703c1180">read_lines()</a>, <a class="el" href="group__cad__mqo__group.html#ga641b3f4c99580c85d5400861c08054a2">read_mqo()</a>, <a class="el" href="group__image__png__group.html#gaa9461efc80789d9d220a31ec48d8e307">read_png()</a>, <a class="el" href="group__image__pnm__group.html#gaafeb86f0cb2f3842dff92fefb8256b85">read_pnm()</a>, <a class="el" href="group__cad__stl__group.html#ga9a693bb830efe008c1794968dffc433c">read_stl()</a>, <a class="el" href="group__image__tga__group.html#ga4d649516d505f02037cf339bb55fcd24">read_tga()</a>, <a class="el" href="group__image__tiff__group.html#gac1f56047db2d6cfc5fad0f815ae58b8e">read_tiff()</a>, <a class="el" href="group__audio__wav__group.html#gac0960f0bfc89fdecb87496573ec33a42">read_wav()</a>, <a class="el" href="group__image__bmp__group.html#gabe15517635af4f3fd6a6d5e3ba8f7dd4">write_bmp()</a>, <a class="el" href="group__image__group.html#ga1b6870eb57258c306d8950e151755767">write_image()</a>, <a class="el" href="group__image__jpeg__group.html#ga03435bd3790b76c2052019c533ad08ec">write_jpeg()</a>, <a class="el" href="group__image__jpeg2000__group.html#ga5af92a0c05b10884c0689b1f75b19eca">write_jpeg2000()</a>, <a class="el" href="group__cad__mqo__group.html#ga117953f522a46a796be9921eb910ac7a">write_mqo()</a>, <a class="el" href="group__image__png__group.html#ga6e1d7d2e15d39ce8c41a5738dfdfe57c">write_png()</a>, <a class="el" href="group__image__pnm__group.html#ga0874ffc7b75914d2525b72412aa2b63e">write_pnm()</a>, <a class="el" href="group__cad__stl__group.html#ga6d72ac8c61cf66e355516511f50ebaff">write_stl()</a>, <a class="el" href="group__image__tga__group.html#ga09a6472ceece709a3c7eb00be35b9e4f">write_tga()</a>, <a class="el" href="group__image__tiff__group.html#ga2ad242e5106004783f84323aa636dbf6">write_tiff()</a>, と <a class="el" href="group__audio__wav__group.html#ga01384af36c55bb6b757db4b53a4c9737">write_wav()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><address style="align: right;"><small>
Generated on Wed Nov 12 2014 19:44:28 for MIST by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.1.2</small></address>
</body>
</html>
